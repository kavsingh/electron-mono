/**
 * Generated by @openapi-codegen
 *
 * @version 1.85.0
 */
import * as reactQuery from "@tanstack/react-query";
import { useNapiContext, NapiContext } from "./napi-context";
import type * as Fetcher from "./napi-fetcher";
import { napiFetch } from "./napi-fetcher";
import type * as Schemas from "./napi-schemas";
import type * as Responses from "./napi-responses";

export type ExportSerialNumbersQueryParams = {
	/*
	 * Licensed product ID.
	 */
	licensedproduct_id: number;
	/*
	 * Amount of serial numbers to export.
	 */
	quantity: number;
	/*
	 * Reason of serial numbers export.
	 */
	notes: string;
	/*
	 * License which has to be attached to the generated serial numbers. See SDBS Supporter UI for possible values.
	 */
	license?: string;
};

export type ExportSerialNumbersError = Fetcher.ErrorWrapper<
	| {
			status: 400;
			payload: Responses.ValidationErrors;
	  }
	| {
			status: 401;
			payload: Responses.UnauthorizedAccess;
	  }
	| {
			status: 404;
			payload: Responses.NotFound;
	  }
	| {
			status: 422;
			payload: Responses.NoItemsLeftOrLicensingSerialsExportError;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type ExportSerialNumbersVariables = {
	queryParams: ExportSerialNumbersQueryParams;
} & NapiContext["fetcherOptions"];

/**
 * Export serial numbers for provided licensed product ID.
 */
export const fetchExportSerialNumbers = (
	variables: ExportSerialNumbersVariables,
) =>
	napiFetch<
		Schemas.SerialNumberExportsResponse,
		ExportSerialNumbersError,
		undefined,
		{},
		ExportSerialNumbersQueryParams,
		{}
	>({ url: "/supporters/serial_number_exports", method: "get", ...variables });

/**
 * Export serial numbers for provided licensed product ID.
 */
export const useExportSerialNumbers = (
	variables: ExportSerialNumbersVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.SerialNumberExportsResponse,
			ExportSerialNumbersError,
			Schemas.SerialNumberExportsResponse
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.SerialNumberExportsResponse,
		ExportSerialNumbersError,
		Schemas.SerialNumberExportsResponse
	>(
		queryKeyFn({
			path: "/supporters/serial_number_exports",
			operationId: "exportSerialNumbers",
			variables,
		}),
		() => fetchExportSerialNumbers({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type GetUserPathParams = {
	/*
	 * NativeID – unique enduser identifier
	 */
	id: string;
};

export type GetUserError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedAccess;
	  }
	| {
			status: 404;
			payload: Responses.NotFound;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type GetUserVariables = {
	pathParams: GetUserPathParams;
} & NapiContext["fetcherOptions"];

/**
 * Retrieve enduser data
 */
export const fetchGetUser = (variables: GetUserVariables) =>
	napiFetch<
		Schemas.Enduser,
		GetUserError,
		undefined,
		{},
		{},
		GetUserPathParams
	>({ url: "/supporters/users/{id}", method: "get", ...variables });

/**
 * Retrieve enduser data
 */
export const useGetUser = (
	variables: GetUserVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<Schemas.Enduser, GetUserError, Schemas.Enduser>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<Schemas.Enduser, GetUserError, Schemas.Enduser>(
		queryKeyFn({
			path: "/supporters/users/{id}",
			operationId: "getUser",
			variables,
		}),
		() => fetchGetUser({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type GetUserLicensedProductsPathParams = {
	/*
	 * NativeID – unique enduser identifier
	 */
	id: string;
};

export type GetUserLicensedProductsError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedAccess;
	  }
	| {
			status: 404;
			payload: Responses.NotFound;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type GetUserLicensedProductsVariables = {
	pathParams: GetUserLicensedProductsPathParams;
} & NapiContext["fetcherOptions"];

/**
 * Retrieve list of enduser licensedproducts
 */
export const fetchGetUserLicensedProducts = (
	variables: GetUserLicensedProductsVariables,
) =>
	napiFetch<
		Schemas.LicensedProductsResponse,
		GetUserLicensedProductsError,
		undefined,
		{},
		{},
		GetUserLicensedProductsPathParams
	>({
		url: "/supporters/users/{id}/licensedproducts",
		method: "get",
		...variables,
	});

/**
 * Retrieve list of enduser licensedproducts
 */
export const useGetUserLicensedProducts = (
	variables: GetUserLicensedProductsVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.LicensedProductsResponse,
			GetUserLicensedProductsError,
			Schemas.LicensedProductsResponse
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.LicensedProductsResponse,
		GetUserLicensedProductsError,
		Schemas.LicensedProductsResponse
	>(
		queryKeyFn({
			path: "/supporters/users/{id}/licensedproducts",
			operationId: "getUserLicensedProducts",
			variables,
		}),
		() => fetchGetUserLicensedProducts({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type GetAllLicensedProductsError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedAccess;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type GetAllLicensedProductsVariables = NapiContext["fetcherOptions"];

/**
 * Retrieve list of all licensedproducts
 */
export const fetchGetAllLicensedProducts = (
	variables: GetAllLicensedProductsVariables,
) =>
	napiFetch<
		Schemas.AllLicensedProductsResponse,
		GetAllLicensedProductsError,
		undefined,
		{},
		{},
		{}
	>({ url: "/supporters/licensedproducts", method: "get", ...variables });

/**
 * Retrieve list of all licensedproducts
 */
export const useGetAllLicensedProducts = (
	variables: GetAllLicensedProductsVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.AllLicensedProductsResponse,
			GetAllLicensedProductsError,
			Schemas.AllLicensedProductsResponse
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.AllLicensedProductsResponse,
		GetAllLicensedProductsError,
		Schemas.AllLicensedProductsResponse
	>(
		queryKeyFn({
			path: "/supporters/licensedproducts",
			operationId: "getAllLicensedProducts",
			variables,
		}),
		() => fetchGetAllLicensedProducts({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type GetUserRegistrationsPathParams = {
	/*
	 * NativeID – unique enduser identifier
	 */
	id: string;
};

export type GetUserRegistrationsError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedAccess;
	  }
	| {
			status: 404;
			payload: Responses.NotFound;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type GetUserRegistrationsVariables = {
	pathParams: GetUserRegistrationsPathParams;
} & NapiContext["fetcherOptions"];

/**
 * Retrieve list of enduser registrations
 */
export const fetchGetUserRegistrations = (
	variables: GetUserRegistrationsVariables,
) =>
	napiFetch<
		Schemas.RegistrationsResponse,
		GetUserRegistrationsError,
		undefined,
		{},
		{},
		GetUserRegistrationsPathParams
	>({
		url: "/supporters/users/{id}/registrations",
		method: "get",
		...variables,
	});

/**
 * Retrieve list of enduser registrations
 */
export const useGetUserRegistrations = (
	variables: GetUserRegistrationsVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.RegistrationsResponse,
			GetUserRegistrationsError,
			Schemas.RegistrationsResponse
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.RegistrationsResponse,
		GetUserRegistrationsError,
		Schemas.RegistrationsResponse
	>(
		queryKeyFn({
			path: "/supporters/users/{id}/registrations",
			operationId: "getUserRegistrations",
			variables,
		}),
		() => fetchGetUserRegistrations({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type GetConfigurationQueryParams = {
	/*
	 * Request Public Keys in provided format, supported values: SubjectPublicKeyInfo, PKCS1. Default is SubjectPublicKeyInfo.
	 * Check SDBS documentation about `get_public_keys` or `get_public_keys_in_format` for more details.
	 */
	pk_format?: string;
};

export type GetConfigurationError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedApplication;
	  }
	| {
			status: 422;
			payload: Responses.ValidationErrors;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type GetConfigurationVariables = {
	queryParams?: GetConfigurationQueryParams;
} & NapiContext["fetcherOptions"];

/**
 * Return all public settings for Native-API.
 */
export const fetchGetConfiguration = (variables: GetConfigurationVariables) =>
	napiFetch<
		Schemas.ConfigurationResponse,
		GetConfigurationError,
		undefined,
		{},
		GetConfigurationQueryParams,
		{}
	>({ url: "/configurations/", method: "get", ...variables });

/**
 * Return all public settings for Native-API.
 */
export const useGetConfiguration = (
	variables: GetConfigurationVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.ConfigurationResponse,
			GetConfigurationError,
			Schemas.ConfigurationResponse
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.ConfigurationResponse,
		GetConfigurationError,
		Schemas.ConfigurationResponse
	>(
		queryKeyFn({
			path: "/configurations/",
			operationId: "getConfiguration",
			variables,
		}),
		() => fetchGetConfiguration({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type GetConfigurationGroupPathParams = {
	/*
	 * Result will only contain entries for of the specified group.
	 */
	group: string;
};

export type GetConfigurationGroupQueryParams = {
	/*
	 * Request Public Keys in provided format, supported values: SubjectPublicKeyInfo, PKCS1. Default is SubjectPublicKeyInfo.
	 * Check SDBS documentation about `get_public_keys` or `get_public_keys_in_format` for more details.
	 */
	pk_format?: string;
};

export type GetConfigurationGroupError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedApplication;
	  }
	| {
			status: 422;
			payload: Responses.ValidationErrors;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type GetConfigurationGroupVariables = {
	pathParams: GetConfigurationGroupPathParams;
	queryParams?: GetConfigurationGroupQueryParams;
} & NapiContext["fetcherOptions"];

/**
 * Return all public settings for Native-API for requested group.
 */
export const fetchGetConfigurationGroup = (
	variables: GetConfigurationGroupVariables,
) =>
	napiFetch<
		Schemas.ConfigurationResponse,
		GetConfigurationGroupError,
		undefined,
		{},
		GetConfigurationGroupQueryParams,
		GetConfigurationGroupPathParams
	>({ url: "/configurations/{group}", method: "get", ...variables });

/**
 * Return all public settings for Native-API for requested group.
 */
export const useGetConfigurationGroup = (
	variables: GetConfigurationGroupVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.ConfigurationResponse,
			GetConfigurationGroupError,
			Schemas.ConfigurationResponse
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.ConfigurationResponse,
		GetConfigurationGroupError,
		Schemas.ConfigurationResponse
	>(
		queryKeyFn({
			path: "/configurations/{group}",
			operationId: "getConfigurationGroup",
			variables,
		}),
		() => fetchGetConfigurationGroup({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type PingError = Fetcher.ErrorWrapper<undefined>;

export type PingResponse = {
	response_head: Schemas.ResponseHead;
	response_body: {
		message: "pong";
	};
};

export type PingVariables = NapiContext["fetcherOptions"];

/**
 * A simple Ping method to check if the API is up and responding. It does not require any message or parameters and always returns a “pong” message as defined above.
 */
export const fetchPing = (variables: PingVariables) =>
	napiFetch<PingResponse, PingError, undefined, {}, {}, {}>({
		url: "/base/ping",
		method: "get",
		...variables,
	});

/**
 * A simple Ping method to check if the API is up and responding. It does not require any message or parameters and always returns a “pong” message as defined above.
 */
export const usePing = (
	variables: PingVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<PingResponse, PingError, PingResponse>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<PingResponse, PingError, PingResponse>(
		queryKeyFn({ path: "/base/ping", operationId: "ping", variables }),
		() => fetchPing({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type CrashError = Fetcher.ErrorWrapper<{
	status: 500;
	payload: Responses.InternalError;
}>;

export type CrashVariables = NapiContext["fetcherOptions"];

/**
 * Always throws an exception. No message required. Don’t expect any output other than a response_head with an error.
 */
export const fetchCrash = (variables: CrashVariables) =>
	napiFetch<undefined, CrashError, undefined, {}, {}, {}>({
		url: "/base/crash",
		method: "get",
		...variables,
	});

/**
 * Always throws an exception. No message required. Don’t expect any output other than a response_head with an error.
 */
export const useCrash = (
	variables: CrashVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<undefined, CrashError, undefined>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<undefined, CrashError, undefined>(
		queryKeyFn({ path: "/base/crash", operationId: "crash", variables }),
		() => fetchCrash({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type PingSdbsError = Fetcher.ErrorWrapper<{
	status: 503;
	payload: Schemas.ErrorResponse;
}>;

export type PingSdbsResponse = {
	response_head: Schemas.ResponseHead;
	response_body: {
		message: "Connected to SDBS at {SDBS_URI}";
	};
};

export type PingSdbsVariables = NapiContext["fetcherOptions"];

/**
 * Requests to the SDBS_URI (HAProxy server of SDBS) to verify if it is reachable, if not will return a connection-error response. This endpoint is intended for monitoring purposes, e.g GCP Monitoring (Uptime checks).
 */
export const fetchPingSdbs = (variables: PingSdbsVariables) =>
	napiFetch<PingSdbsResponse, PingSdbsError, undefined, {}, {}, {}>({
		url: "/base/ping_sdbs",
		method: "get",
		...variables,
	});

/**
 * Requests to the SDBS_URI (HAProxy server of SDBS) to verify if it is reachable, if not will return a connection-error response. This endpoint is intended for monitoring purposes, e.g GCP Monitoring (Uptime checks).
 */
export const usePingSdbs = (
	variables: PingSdbsVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			PingSdbsResponse,
			PingSdbsError,
			PingSdbsResponse
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<PingSdbsResponse, PingSdbsError, PingSdbsResponse>(
		queryKeyFn({ path: "/base/ping_sdbs", operationId: "pingSdbs", variables }),
		() => fetchPingSdbs({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type PingRabbitmqError = Fetcher.ErrorWrapper<{
	status: 503;
	payload: Schemas.ErrorResponse;
}>;

export type PingRabbitmqResponse = {
	response_head: Schemas.ResponseHead;
	response_body: {
		message: "RabbitMQ server is alive at {AMQP_IMPORTER_URI}";
	};
};

export type PingRabbitmqVariables = NapiContext["fetcherOptions"];

/**
 * Verifies that the connection to rabbitmq is open at AMQP_IMPORTER_URI, if not then it will return a connection-error response. This endpoint is intended for monitoring purposes, e.g GCP Monitoring (Uptime checks).
 */
export const fetchPingRabbitmq = (variables: PingRabbitmqVariables) =>
	napiFetch<PingRabbitmqResponse, PingRabbitmqError, undefined, {}, {}, {}>({
		url: "/base/ping_rabbitmq",
		method: "get",
		...variables,
	});

/**
 * Verifies that the connection to rabbitmq is open at AMQP_IMPORTER_URI, if not then it will return a connection-error response. This endpoint is intended for monitoring purposes, e.g GCP Monitoring (Uptime checks).
 */
export const usePingRabbitmq = (
	variables: PingRabbitmqVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			PingRabbitmqResponse,
			PingRabbitmqError,
			PingRabbitmqResponse
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		PingRabbitmqResponse,
		PingRabbitmqError,
		PingRabbitmqResponse
	>(
		queryKeyFn({
			path: "/base/ping_rabbitmq",
			operationId: "pingRabbitmq",
			variables,
		}),
		() => fetchPingRabbitmq({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type AuthenticateError = Fetcher.ErrorWrapper<{
	status: 401;
	payload: Schemas.ErrorResponse;
}>;

export type AuthenticateVariables = {
	body: Schemas.Credentials;
} & NapiContext["fetcherOptions"];

/**
 * Returns a new pair of Access and Refresh Tokens if the given credentials are correct and the Application Token in the Request Header has been registered.
 */
export const fetchAuthenticate = (variables: AuthenticateVariables) =>
	napiFetch<
		Schemas.AuthTokenResponse,
		AuthenticateError,
		Schemas.Credentials,
		{},
		{},
		{}
	>({ url: "/auth/token", method: "post", ...variables });

/**
 * Returns a new pair of Access and Refresh Tokens if the given credentials are correct and the Application Token in the Request Header has been registered.
 */
export const useAuthenticate = (
	options?: Omit<
		reactQuery.UseMutationOptions<
			Schemas.AuthTokenResponse,
			AuthenticateError,
			AuthenticateVariables
		>,
		"mutationFn"
	>,
) => {
	const { fetcherOptions } = useNapiContext();
	return reactQuery.useMutation<
		Schemas.AuthTokenResponse,
		AuthenticateError,
		AuthenticateVariables
	>(
		(variables: AuthenticateVariables) =>
			fetchAuthenticate({ ...fetcherOptions, ...variables }),
		options,
	);
};

export type RefreshTokenError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Schemas.ErrorResponse;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type RefreshTokenVariables = NapiContext["fetcherOptions"];

/**
 * Requests a new Access and Refresh Tokens with an existing Refresh Token. This method does not expect an input message, it is sufficient to specify the Refresh Token as Bearer in the Request Header.
 */
export const fetchRefreshToken = (variables: RefreshTokenVariables) =>
	napiFetch<
		Schemas.AuthTokenResponse,
		RefreshTokenError,
		undefined,
		{},
		{},
		{}
	>({ url: "/auth/refresh_token", method: "post", ...variables });

/**
 * Requests a new Access and Refresh Tokens with an existing Refresh Token. This method does not expect an input message, it is sufficient to specify the Refresh Token as Bearer in the Request Header.
 */
export const useRefreshToken = (
	options?: Omit<
		reactQuery.UseMutationOptions<
			Schemas.AuthTokenResponse,
			RefreshTokenError,
			RefreshTokenVariables
		>,
		"mutationFn"
	>,
) => {
	const { fetcherOptions } = useNapiContext();
	return reactQuery.useMutation<
		Schemas.AuthTokenResponse,
		RefreshTokenError,
		RefreshTokenVariables
	>(
		(variables: RefreshTokenVariables) =>
			fetchRefreshToken({ ...fetcherOptions, ...variables }),
		options,
	);
};

export type RecoverPasswordError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedApplication;
	  }
	| {
			status: 422;
			payload: Responses.ValidationErrors;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type RecoverPasswordResponse = {
	response_head?: Schemas.ResponseHead;
	response_body?: {
		message?: string;
	};
};

export type RecoverPasswordRequestBody = {
	/*
	 * @minLength 1
	 */
	username?: string;
};

export type RecoverPasswordVariables = {
	body?: RecoverPasswordRequestBody;
} & NapiContext["fetcherOptions"];

/**
 * Recovers password for a native instruments user based on username.
 */
export const fetchRecoverPassword = (variables: RecoverPasswordVariables) =>
	napiFetch<
		RecoverPasswordResponse,
		RecoverPasswordError,
		RecoverPasswordRequestBody,
		{},
		{},
		{}
	>({ url: "/auth/recover_password", method: "post", ...variables });

/**
 * Recovers password for a native instruments user based on username.
 */
export const useRecoverPassword = (
	options?: Omit<
		reactQuery.UseMutationOptions<
			RecoverPasswordResponse,
			RecoverPasswordError,
			RecoverPasswordVariables
		>,
		"mutationFn"
	>,
) => {
	const { fetcherOptions } = useNapiContext();
	return reactQuery.useMutation<
		RecoverPasswordResponse,
		RecoverPasswordError,
		RecoverPasswordVariables
	>(
		(variables: RecoverPasswordVariables) =>
			fetchRecoverPassword({ ...fetcherOptions, ...variables }),
		options,
	);
};

export type ActivateError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedAccess;
	  }
	| {
			status: 422;
			payload: Schemas.ActivationResponse;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type ActivateVariables = {
	body?: Schemas.ActivationRequest;
} & NapiContext["fetcherOptions"];

/**
 * Activates a list of product serials and system IDs. Returns a list of responses, each containing a `serial` field containing the serial that was to be activated and either a `result` field in case of success, or an `error` field, which is structured exactly like `field_errors` described in Response structure & fields.
 *
 * Accepts an optional `method` parameter to determine the activation method that’s to be used.
 *
 * When a RAS3 bundled product is to be activated you must include both serial numbers for the bundle master and bundle members.
 *
 * When activating a bundle master an empty string as a system ID is allowed.
 */
export const fetchActivate = (variables: ActivateVariables) =>
	napiFetch<
		Schemas.ActivationResponse,
		ActivateError,
		Schemas.ActivationRequest,
		{},
		{},
		{}
	>({ url: "/activations/", method: "post", ...variables });

/**
 * Activates a list of product serials and system IDs. Returns a list of responses, each containing a `serial` field containing the serial that was to be activated and either a `result` field in case of success, or an `error` field, which is structured exactly like `field_errors` described in Response structure & fields.
 *
 * Accepts an optional `method` parameter to determine the activation method that’s to be used.
 *
 * When a RAS3 bundled product is to be activated you must include both serial numbers for the bundle master and bundle members.
 *
 * When activating a bundle master an empty string as a system ID is allowed.
 */
export const useActivate = (
	options?: Omit<
		reactQuery.UseMutationOptions<
			Schemas.ActivationResponse,
			ActivateError,
			ActivateVariables
		>,
		"mutationFn"
	>,
) => {
	const { fetcherOptions } = useNapiContext();
	return reactQuery.useMutation<
		Schemas.ActivationResponse,
		ActivateError,
		ActivateVariables
	>(
		(variables: ActivateVariables) =>
			fetchActivate({ ...fetcherOptions, ...variables }),
		options,
	);
};

export type GetCompleteChangelogPathParams = {
	upid: string;
};

export type GetCompleteChangelogError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedApplication;
	  }
	| {
			status: 404;
			payload: Responses.NotFound;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type GetCompleteChangelogVariables = {
	pathParams: GetCompleteChangelogPathParams;
} & NapiContext["fetcherOptions"];

/**
 * Returns the complete Changelog for a given UPID.
 */
export const fetchGetCompleteChangelog = (
	variables: GetCompleteChangelogVariables,
) =>
	napiFetch<
		Schemas.CompleteChangelogResult,
		GetCompleteChangelogError,
		undefined,
		{},
		{},
		GetCompleteChangelogPathParams
	>({ url: "/changelogs/{upid}", method: "get", ...variables });

/**
 * Returns the complete Changelog for a given UPID.
 */
export const useGetCompleteChangelog = (
	variables: GetCompleteChangelogVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.CompleteChangelogResult,
			GetCompleteChangelogError,
			Schemas.CompleteChangelogResult
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.CompleteChangelogResult,
		GetCompleteChangelogError,
		Schemas.CompleteChangelogResult
	>(
		queryKeyFn({
			path: "/changelogs/{upid}",
			operationId: "getCompleteChangelog",
			variables,
		}),
		() => fetchGetCompleteChangelog({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type GetPartialChangelogPathParams = {
	upid: string;
	fromVersion: string;
	toVersion: string;
};

export type GetPartialChangelogError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedApplication;
	  }
	| {
			status: 404;
			payload: Responses.NotFound;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type GetPartialChangelogVariables = {
	pathParams: GetPartialChangelogPathParams;
} & NapiContext["fetcherOptions"];

export const fetchGetPartialChangelog = (
	variables: GetPartialChangelogVariables,
) =>
	napiFetch<
		Schemas.CompleteChangelogResult,
		GetPartialChangelogError,
		undefined,
		{},
		{},
		GetPartialChangelogPathParams
	>({
		url: "/changelogs/{upid}/{fromVersion}/{toVersion}",
		method: "get",
		...variables,
	});

export const useGetPartialChangelog = (
	variables: GetPartialChangelogVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.CompleteChangelogResult,
			GetPartialChangelogError,
			Schemas.CompleteChangelogResult
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.CompleteChangelogResult,
		GetPartialChangelogError,
		Schemas.CompleteChangelogResult
	>(
		queryKeyFn({
			path: "/changelogs/{upid}/{from_version}/{to_version}",
			operationId: "getPartialChangelog",
			variables,
		}),
		() => fetchGetPartialChangelog({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type DownloadProductPathParams = {
	upid: string;
};

export type DownloadProductQueryParams = {
	/*
	 * If false, the response contains all artifacts with `platform != nativeos`. If true, the response contains all artifacts.
	 */
	show_nativeos?: boolean;
	/*
	 * If not provided, the response contains all artifacts regardless of their hardware_platform. If provided, the response contains artifacts with matching hardware_platform. Artifacts with `hardware_platform == any` are always returned.
	 */
	hardware_platform?: string;
};

export type DownloadProductError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedApplication;
	  }
	| {
			status: 404;
			payload: Responses.NotFound;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type DownloadProductVariables = {
	pathParams: DownloadProductPathParams;
	queryParams?: DownloadProductQueryParams;
} & NapiContext["fetcherOptions"];

/**
 * Returns the list of full products (i.e. not updates or players) associated with the given UPID. Deprecated in favour of `GET /download/me/full-products` and `GET /download/me/updates`.
 */
export const fetchDownloadProduct = (variables: DownloadProductVariables) =>
	napiFetch<
		Schemas.DownloadProductsResponseLegacy,
		DownloadProductError,
		undefined,
		{},
		DownloadProductQueryParams,
		DownloadProductPathParams
	>({ url: "/download/full-products/{upid}", method: "get", ...variables });

/**
 * Returns the list of full products (i.e. not updates or players) associated with the given UPID. Deprecated in favour of `GET /download/me/full-products` and `GET /download/me/updates`.
 */
export const useDownloadProduct = (
	variables: DownloadProductVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.DownloadProductsResponseLegacy,
			DownloadProductError,
			Schemas.DownloadProductsResponseLegacy
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.DownloadProductsResponseLegacy,
		DownloadProductError,
		Schemas.DownloadProductsResponseLegacy
	>(
		queryKeyFn({
			path: "/download/full-products/{upid}",
			operationId: "downloadProduct",
			variables,
		}),
		() => fetchDownloadProduct({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type GetMyFullProductsDownloadsQueryParams = {
	/*
	 * If not provided, the response contains all artifacts regardless of `platform`. If provided, the response contains artifacts with matching platform. If mac or pc is provided, the response also contains artifacts with platform=all.
	 */
	platform?: "pc" | "mac" | "linux-x86_64" | "nativeos";
	/*
	 * If not provided, the response contains all artifacts regardless of their `hardware_platform`. If provided, the response contains artifacts with matching hardware_platform. Artifacts with `hardware_platform == any` are always returned.
	 */
	hardware_platform?: "mas-x86_64";
	/*
	 * If not provided, the response contains all artifacts regardless of their `os_min`/`os_max`. If provided, and if platform is provided, the response contains all artifacts where `os_min <= platform_version <= os_max`. If `os_min` is `null`, that is equivalent to `0`, and if `os_max` is `null`, that is equivalent to `+Inf`.
	 *
	 * @pattern ^(\d+)?(\.\d+)*$
	 */
	platform_version?: string;
	/*
	 * If set to `true`, single artifact with latest version available will be returned
	 *
	 * @default false
	 */
	latest_only?: boolean;
	/*
	 * If set to `true`, response will also contains subscription products
	 *
	 * @default false
	 */
	include_subscriptions?: boolean;
};

export type GetMyFullProductsDownloadsError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedAccess;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type GetMyFullProductsDownloadsVariables = {
	queryParams?: GetMyFullProductsDownloadsQueryParams;
} & NapiContext["fetcherOptions"];

export const fetchGetMyFullProductsDownloads = (
	variables: GetMyFullProductsDownloadsVariables,
) =>
	napiFetch<
		Schemas.DownloadProductsResponse,
		GetMyFullProductsDownloadsError,
		undefined,
		{},
		GetMyFullProductsDownloadsQueryParams,
		{}
	>({ url: "/download/me/full-products", method: "get", ...variables });

export const useGetMyFullProductsDownloads = (
	variables: GetMyFullProductsDownloadsVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.DownloadProductsResponse,
			GetMyFullProductsDownloadsError,
			Schemas.DownloadProductsResponse
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.DownloadProductsResponse,
		GetMyFullProductsDownloadsError,
		Schemas.DownloadProductsResponse
	>(
		queryKeyFn({
			path: "/download/me/full-products",
			operationId: "getMyFullProductsDownloads",
			variables,
		}),
		() => fetchGetMyFullProductsDownloads({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type DownloadProductUpdatesPathParams = {
	upid: string;
};

export type DownloadProductUpdatesQueryParams = {
	/*
	 * If false, the response contains all artifacts with `platform != nativeos`. If true, the response contains all artifacts.
	 */
	show_nativeos?: boolean;
	/*
	 * If not provided, the response contains all artifacts regardless of their hardware_platform. If provided, the response contains artifacts with matching hardware_platform. Artifacts with `hardware_platform == any` are always returned.
	 */
	hardware_platform?: string;
};

export type DownloadProductUpdatesError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedApplication;
	  }
	| {
			status: 404;
			payload: Responses.NotFound;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type DownloadProductUpdatesVariables = {
	pathParams: DownloadProductUpdatesPathParams;
	queryParams?: DownloadProductUpdatesQueryParams;
} & NapiContext["fetcherOptions"];

/**
 * Returns the list of updates associated with the given UPID. Deprecated in favour of `GET /download/me/full-products` and `GET /download/me/updates`.
 */
export const fetchDownloadProductUpdates = (
	variables: DownloadProductUpdatesVariables,
) =>
	napiFetch<
		Schemas.DownloadProductsResponseLegacy,
		DownloadProductUpdatesError,
		undefined,
		{},
		DownloadProductUpdatesQueryParams,
		DownloadProductUpdatesPathParams
	>({ url: "/download/updates/{upid}", method: "get", ...variables });

/**
 * Returns the list of updates associated with the given UPID. Deprecated in favour of `GET /download/me/full-products` and `GET /download/me/updates`.
 */
export const useDownloadProductUpdates = (
	variables: DownloadProductUpdatesVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.DownloadProductsResponseLegacy,
			DownloadProductUpdatesError,
			Schemas.DownloadProductsResponseLegacy
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.DownloadProductsResponseLegacy,
		DownloadProductUpdatesError,
		Schemas.DownloadProductsResponseLegacy
	>(
		queryKeyFn({
			path: "/download/updates/{upid}",
			operationId: "downloadProductUpdates",
			variables,
		}),
		() => fetchDownloadProductUpdates({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type GetMyProductUpdatesDownloadsQueryParams = {
	/*
	 * If not provided, the response contains all artifacts regardless of `platform`. If provided, the response contains artifacts with matching platform. If mac or pc is provided, the response also contains artifacts with platform=all.
	 */
	platform?: "pc" | "mac" | "linux-x86_64" | "nativeos";
	/*
	 * If not provided, the response contains all artifacts regardless of their `hardware_platform`. If provided, the response contains artifacts with matching hardware_platform. Artifacts with `hardware_platform == any` are always returned.
	 */
	hardware_platform?: "mas-x86_64";
	/*
	 * If not provided, the response contains all artifacts regardless of their `os_min`/`os_max`. If provided, and if platform is provided, the response contains all artifacts where `os_min <= platform_version <= os_max`. If `os_min` is `null`, that is equivalent to `0`, and if `os_max` is `null`, that is equivalent to `+Inf`.
	 *
	 * @pattern ^(\d+)?(\.\d+)*$
	 */
	platform_version?: string;
	/*
	 * If set to `true`, single artifact with latest version available will be returned
	 *
	 * @default false
	 */
	latest_only?: boolean;
	/*
	 * If set to `true` response will contains also subscription products
	 *
	 * @default false
	 */
	include_subscriptions?: boolean;
};

export type GetMyProductUpdatesDownloadsError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedAccess;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type GetMyProductUpdatesDownloadsVariables = {
	queryParams?: GetMyProductUpdatesDownloadsQueryParams;
} & NapiContext["fetcherOptions"];

export const fetchGetMyProductUpdatesDownloads = (
	variables: GetMyProductUpdatesDownloadsVariables,
) =>
	napiFetch<
		Schemas.DownloadProductsResponse,
		GetMyProductUpdatesDownloadsError,
		undefined,
		{},
		GetMyProductUpdatesDownloadsQueryParams,
		{}
	>({ url: "/download/me/updates", method: "get", ...variables });

export const useGetMyProductUpdatesDownloads = (
	variables: GetMyProductUpdatesDownloadsVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.DownloadProductsResponse,
			GetMyProductUpdatesDownloadsError,
			Schemas.DownloadProductsResponse
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.DownloadProductsResponse,
		GetMyProductUpdatesDownloadsError,
		Schemas.DownloadProductsResponse
	>(
		queryKeyFn({
			path: "/download/me/updates",
			operationId: "getMyProductUpdatesDownloads",
			variables,
		}),
		() =>
			fetchGetMyProductUpdatesDownloads({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type GetMyProductContentDownloadsQueryParams = {
	/*
	 * If not provided, the response contains all artifacts regardless of `platform`. If provided, the response contains artifacts with matching platform. If mac or pc is provided, the response also contains artifacts with platform=all.
	 */
	platform?: "pc" | "mac" | "linux-x86_64" | "nativeos";
	/*
	 * If not provided, the response contains all artifacts regardless of their `hardware_platform`. If provided, the response contains artifacts with matching hardware_platform. Artifacts with `hardware_platform == any` are always returned.
	 */
	hardware_platform?: "mas-x86_64";
	/*
	 * If not provided, the response contains all artifacts regardless of their `os_min`/`os_max`. If provided, and if platform is provided, the response contains all artifacts where `os_min <= platform_version <= os_max`. If `os_min` is `null`, that is equivalent to `0`, and if `os_max` is `null`, that is equivalent to `+Inf`.
	 *
	 * @pattern ^(\d+)?(\.\d+)*$
	 */
	platform_version?: string;
	/*
	 * If set to `true`, single artifact with latest version available will be returned
	 *
	 * @default false
	 */
	latest_only?: boolean;
	/*
	 * If set to `true` response will contains also subscription products
	 *
	 * @default false
	 */
	include_subscriptions?: boolean;
};

export type GetMyProductContentDownloadsError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedAccess;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type GetMyProductContentDownloadsVariables = {
	queryParams?: GetMyProductContentDownloadsQueryParams;
} & NapiContext["fetcherOptions"];

export const fetchGetMyProductContentDownloads = (
	variables: GetMyProductContentDownloadsVariables,
) =>
	napiFetch<
		Schemas.DownloadProductsResponse,
		GetMyProductContentDownloadsError,
		undefined,
		{},
		GetMyProductContentDownloadsQueryParams,
		{}
	>({ url: "/download/me/content", method: "get", ...variables });

export const useGetMyProductContentDownloads = (
	variables: GetMyProductContentDownloadsVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.DownloadProductsResponse,
			GetMyProductContentDownloadsError,
			Schemas.DownloadProductsResponse
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.DownloadProductsResponse,
		GetMyProductContentDownloadsError,
		Schemas.DownloadProductsResponse
	>(
		queryKeyFn({
			path: "/download/me/content",
			operationId: "getMyProductContentDownloads",
			variables,
		}),
		() =>
			fetchGetMyProductContentDownloads({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type DownloadPlayerPathParams = {
	upid: string;
};

export type DownloadPlayerError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedApplication;
	  }
	| {
			status: 404;
			payload: Responses.NotFound;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type DownloadPlayerVariables = {
	pathParams: DownloadPlayerPathParams;
} & NapiContext["fetcherOptions"];

/**
 * Returns the list of players associated with the given UPID. No longer used by current versions of NA and the daemon.
 */
export const fetchDownloadPlayer = (variables: DownloadPlayerVariables) =>
	napiFetch<
		Schemas.DownloadProductsResponseLegacy,
		DownloadPlayerError,
		undefined,
		{},
		{},
		DownloadPlayerPathParams
	>({ url: "/download/players/{upid}", method: "get", ...variables });

/**
 * Returns the list of players associated with the given UPID. No longer used by current versions of NA and the daemon.
 */
export const useDownloadPlayer = (
	variables: DownloadPlayerVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.DownloadProductsResponseLegacy,
			DownloadPlayerError,
			Schemas.DownloadProductsResponseLegacy
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.DownloadProductsResponseLegacy,
		DownloadPlayerError,
		Schemas.DownloadProductsResponseLegacy
	>(
		queryKeyFn({
			path: "/download/players/{upid}",
			operationId: "downloadPlayer",
			variables,
		}),
		() => fetchDownloadPlayer({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type DownloadLinksPathParams = {
	upid: string;
	fileId: string;
};

export type DownloadLinksError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedApplication;
	  }
	| {
			status: 404;
			payload: Responses.NotFound;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type DownloadLinksVariables = {
	pathParams: DownloadLinksPathParams;
} & NapiContext["fetcherOptions"];

/**
 * Retrieves the list of links for the given UPID and file ID. If the ‘authentication required’ box is ticked in UDM2 for the given file, you’ll need to provide a valid access token in the Authorization header.
 *
 * This returns a metalink file.
 */
export const fetchDownloadLinks = (variables: DownloadLinksVariables) =>
	napiFetch<
		undefined,
		DownloadLinksError,
		undefined,
		{},
		{},
		DownloadLinksPathParams
	>({ url: "/download/links/{upid}/{fileId}", method: "get", ...variables });

/**
 * Retrieves the list of links for the given UPID and file ID. If the ‘authentication required’ box is ticked in UDM2 for the given file, you’ll need to provide a valid access token in the Authorization header.
 *
 * This returns a metalink file.
 */
export const useDownloadLinks = (
	variables: DownloadLinksVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<undefined, DownloadLinksError, undefined>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<undefined, DownloadLinksError, undefined>(
		queryKeyFn({
			path: "/download/links/{upid}/{file_id}",
			operationId: "downloadLinks",
			variables,
		}),
		() => fetchDownloadLinks({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type LicenseTransferError = Fetcher.ErrorWrapper<
	| {
			status: 400;
			payload: Schemas.ErrorResponse;
	  }
	| {
			status: 401;
			payload: Responses.UnauthorizedAccess;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type LicenseTransferVariables = {
	body?: Schemas.LicenseTransferRequest;
} & NapiContext["fetcherOptions"];

/**
 * Queues license transfer request.
 */
export const fetchLicenseTransfer = (variables: LicenseTransferVariables) =>
	napiFetch<
		Schemas.LicenseTransferResponse,
		LicenseTransferError,
		Schemas.LicenseTransferRequest,
		{},
		{},
		{}
	>({ url: "/license-transfer/", method: "post", ...variables });

/**
 * Queues license transfer request.
 */
export const useLicenseTransfer = (
	options?: Omit<
		reactQuery.UseMutationOptions<
			Schemas.LicenseTransferResponse,
			LicenseTransferError,
			LicenseTransferVariables
		>,
		"mutationFn"
	>,
) => {
	const { fetcherOptions } = useNapiContext();
	return reactQuery.useMutation<
		Schemas.LicenseTransferResponse,
		LicenseTransferError,
		LicenseTransferVariables
	>(
		(variables: LicenseTransferVariables) =>
			fetchLicenseTransfer({ ...fetcherOptions, ...variables }),
		options,
	);
};

export type GetProductsError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedApplication;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type GetProductsVariables = NapiContext["fetcherOptions"];

/**
 * Returns the list of all known Product IDs (UPIDs).
 */
export const fetchGetProducts = (variables: GetProductsVariables) =>
	napiFetch<Schemas.ProductResponse, GetProductsError, undefined, {}, {}, {}>({
		url: "/products/",
		method: "get",
		...variables,
	});

/**
 * Returns the list of all known Product IDs (UPIDs).
 */
export const useGetProducts = (
	variables: GetProductsVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.ProductResponse,
			GetProductsError,
			Schemas.ProductResponse
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.ProductResponse,
		GetProductsError,
		Schemas.ProductResponse
	>(
		queryKeyFn({ path: "/products/", operationId: "getProducts", variables }),
		() => fetchGetProducts({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type GetSingleProductPathParams = {
	/*
	 * UPID of product
	 *
	 * @format uuid
	 */
	upid: string;
};

export type GetSingleProductError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedApplication;
	  }
	| {
			status: 404;
			payload: Responses.NotFound;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type GetSingleProductVariables = {
	pathParams: GetSingleProductPathParams;
} & NapiContext["fetcherOptions"];

/**
 * Returns all the resources and categories associated with a UPID. Note: this endpoint returns a full, detailed list of all resources attached the given UPID. However, for categories, only the IDs are  returned.
 * The `upid` has to be a valid UUID (see [`uuid.UUID`](https://docs.python.org/3/library/uuid.html#uuid.UUID)).
 */
export const fetchGetSingleProduct = (variables: GetSingleProductVariables) =>
	napiFetch<
		Schemas.ProductByUpidResponse,
		GetSingleProductError,
		undefined,
		{},
		{},
		GetSingleProductPathParams
	>({ url: "/products/{upid}", method: "get", ...variables });

/**
 * Returns all the resources and categories associated with a UPID. Note: this endpoint returns a full, detailed list of all resources attached the given UPID. However, for categories, only the IDs are  returned.
 * The `upid` has to be a valid UUID (see [`uuid.UUID`](https://docs.python.org/3/library/uuid.html#uuid.UUID)).
 */
export const useGetSingleProduct = (
	variables: GetSingleProductVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.ProductByUpidResponse,
			GetSingleProductError,
			Schemas.ProductByUpidResponse
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.ProductByUpidResponse,
		GetSingleProductError,
		Schemas.ProductByUpidResponse
	>(
		queryKeyFn({
			path: "/products/{upid}",
			operationId: "getSingleProduct",
			variables,
		}),
		() => fetchGetSingleProduct({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type GetProductCategoriesError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedApplication;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type GetProductCategoriesVariables = NapiContext["fetcherOptions"];

/**
 * Returns a list of categories, their sort order and relationships.
 */
export const fetchGetProductCategories = (
	variables: GetProductCategoriesVariables,
) =>
	napiFetch<
		Schemas.CategoryResponse,
		GetProductCategoriesError,
		undefined,
		{},
		{},
		{}
	>({ url: "/products/categories", method: "get", ...variables });

/**
 * Returns a list of categories, their sort order and relationships.
 */
export const useGetProductCategories = (
	variables: GetProductCategoriesVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.CategoryResponse,
			GetProductCategoriesError,
			Schemas.CategoryResponse
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.CategoryResponse,
		GetProductCategoriesError,
		Schemas.CategoryResponse
	>(
		queryKeyFn({
			path: "/products/categories",
			operationId: "getProductCategories",
			variables,
		}),
		() => fetchGetProductCategories({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type GetSubscriptionDetailsPathParams = {
	/*
	 * Subscription ID.
	 */
	subscriptionId: number;
};

export type GetSubscriptionDetailsError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedAccess;
	  }
	| {
			status: 404;
			payload: Responses.NotFound;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type GetSubscriptionDetailsVariables = {
	pathParams: GetSubscriptionDetailsPathParams;
} & NapiContext["fetcherOptions"];

/**
 * Returns all details about subscription specified by ID.
 */
export const fetchGetSubscriptionDetails = (
	variables: GetSubscriptionDetailsVariables,
) =>
	napiFetch<
		Schemas.Subscription,
		GetSubscriptionDetailsError,
		undefined,
		{},
		{},
		GetSubscriptionDetailsPathParams
	>({ url: "/subscriptions/{subscriptionId}", method: "get", ...variables });

/**
 * Returns all details about subscription specified by ID.
 */
export const useGetSubscriptionDetails = (
	variables: GetSubscriptionDetailsVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.Subscription,
			GetSubscriptionDetailsError,
			Schemas.Subscription
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.Subscription,
		GetSubscriptionDetailsError,
		Schemas.Subscription
	>(
		queryKeyFn({
			path: "/subscriptions/{subscription_id}",
			operationId: "getSubscriptionDetails",
			variables,
		}),
		() => fetchGetSubscriptionDetails({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type CreateSubscriptionError = Fetcher.ErrorWrapper<
	| {
			status: 400;
			payload: Responses.ValidationErrors;
	  }
	| {
			status: 401;
			payload: Responses.UnauthorizedAccess;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type CreateSubscriptionVariables = {
	body?: Schemas.SubscriptionCreation;
} & NapiContext["fetcherOptions"];

/**
 * Create subscription.
 */
export const fetchCreateSubscription = (
	variables: CreateSubscriptionVariables,
) =>
	napiFetch<
		Schemas.Subscription,
		CreateSubscriptionError,
		Schemas.SubscriptionCreation,
		{},
		{},
		{}
	>({ url: "/subscriptions", method: "post", ...variables });

/**
 * Create subscription.
 */
export const useCreateSubscription = (
	options?: Omit<
		reactQuery.UseMutationOptions<
			Schemas.Subscription,
			CreateSubscriptionError,
			CreateSubscriptionVariables
		>,
		"mutationFn"
	>,
) => {
	const { fetcherOptions } = useNapiContext();
	return reactQuery.useMutation<
		Schemas.Subscription,
		CreateSubscriptionError,
		CreateSubscriptionVariables
	>(
		(variables: CreateSubscriptionVariables) =>
			fetchCreateSubscription({ ...fetcherOptions, ...variables }),
		options,
	);
};

export type GetSubscriptionBundlesQueryParams = {
	/*
	 * SDBS licensed product Id
	 *
	 * @format uint64
	 */
	licensedproduct_id?: number;
};

export type GetSubscriptionBundlesError = Fetcher.ErrorWrapper<
	| {
			status: 400;
			payload: Responses.ValidationErrors;
	  }
	| {
			status: 401;
			payload: Responses.UnauthorizedAccess;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type GetSubscriptionBundlesVariables = {
	queryParams?: GetSubscriptionBundlesQueryParams;
} & NapiContext["fetcherOptions"];

/**
 * Get all subscription Bundles. If a product_id is given it will return all the bundles that have the product.
 */
export const fetchGetSubscriptionBundles = (
	variables: GetSubscriptionBundlesVariables,
) =>
	napiFetch<
		Schemas.SubscriptionBundleResponse,
		GetSubscriptionBundlesError,
		undefined,
		{},
		GetSubscriptionBundlesQueryParams,
		{}
	>({ url: "/subscriptions/bundles", method: "get", ...variables });

/**
 * Get all subscription Bundles. If a product_id is given it will return all the bundles that have the product.
 */
export const useGetSubscriptionBundles = (
	variables: GetSubscriptionBundlesVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.SubscriptionBundleResponse,
			GetSubscriptionBundlesError,
			Schemas.SubscriptionBundleResponse
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.SubscriptionBundleResponse,
		GetSubscriptionBundlesError,
		Schemas.SubscriptionBundleResponse
	>(
		queryKeyFn({
			path: "/subscriptions/bundles",
			operationId: "getSubscriptionBundles",
			variables,
		}),
		() => fetchGetSubscriptionBundles({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type UpdateSubscriptionStatusPathParams = {
	/*
	 * Subscription ID.
	 */
	subscriptionId: number;
};

export type UpdateSubscriptionStatusError = Fetcher.ErrorWrapper<
	| {
			status: 404;
			payload: Responses.NotFound;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type UpdateSubscriptionStatusVariables = {
	body?: Schemas.SubscriptionStatus | Schemas.SubscriptionCancellationStatus;
	pathParams: UpdateSubscriptionStatusPathParams;
} & NapiContext["fetcherOptions"];

/**
 * Updates the status of the subscription
 */
export const fetchUpdateSubscriptionStatus = (
	variables: UpdateSubscriptionStatusVariables,
) =>
	napiFetch<
		Schemas.Subscription,
		UpdateSubscriptionStatusError,
		Schemas.SubscriptionStatus | Schemas.SubscriptionCancellationStatus,
		{},
		{},
		UpdateSubscriptionStatusPathParams
	>({ url: "/subscription/{subscriptionId}/", method: "patch", ...variables });

/**
 * Updates the status of the subscription
 */
export const useUpdateSubscriptionStatus = (
	options?: Omit<
		reactQuery.UseMutationOptions<
			Schemas.Subscription,
			UpdateSubscriptionStatusError,
			UpdateSubscriptionStatusVariables
		>,
		"mutationFn"
	>,
) => {
	const { fetcherOptions } = useNapiContext();
	return reactQuery.useMutation<
		Schemas.Subscription,
		UpdateSubscriptionStatusError,
		UpdateSubscriptionStatusVariables
	>(
		(variables: UpdateSubscriptionStatusVariables) =>
			fetchUpdateSubscriptionStatus({ ...fetcherOptions, ...variables }),
		options,
	);
};

export type GetUsersSubscriptionInformationPathParams = {
	/*
	 * Native ID.
	 */
	nativeId: string;
};

export type GetUsersSubscriptionInformationError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedAccess;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type GetUsersSubscriptionInformationVariables = {
	pathParams: GetUsersSubscriptionInformationPathParams;
} & NapiContext["fetcherOptions"];

export const fetchGetUsersSubscriptionInformation = (
	variables: GetUsersSubscriptionInformationVariables,
) =>
	napiFetch<
		Schemas.SubscriptionUserInfo,
		GetUsersSubscriptionInformationError,
		undefined,
		{},
		{},
		GetUsersSubscriptionInformationPathParams
	>({ url: "/subscriptions/users/{nativeId}", method: "get", ...variables });

export const useGetUsersSubscriptionInformation = (
	variables: GetUsersSubscriptionInformationVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.SubscriptionUserInfo,
			GetUsersSubscriptionInformationError,
			Schemas.SubscriptionUserInfo
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.SubscriptionUserInfo,
		GetUsersSubscriptionInformationError,
		Schemas.SubscriptionUserInfo
	>(
		queryKeyFn({
			path: "/subscriptions/users/{native_id}",
			operationId: "getUsersSubscriptionInformation",
			variables,
		}),
		() =>
			fetchGetUsersSubscriptionInformation({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type GetSubscriptionInvoicesPathParams = {
	/*
	 * Subscription ID.
	 */
	subscriptionId: number;
};

export type GetSubscriptionInvoicesError = Fetcher.ErrorWrapper<undefined>;

export type GetSubscriptionInvoicesVariables = {
	pathParams: GetSubscriptionInvoicesPathParams;
} & NapiContext["fetcherOptions"];

export const fetchGetSubscriptionInvoices = (
	variables: GetSubscriptionInvoicesVariables,
) =>
	napiFetch<
		Schemas.SubscriptionInvoice,
		GetSubscriptionInvoicesError,
		undefined,
		{},
		{},
		GetSubscriptionInvoicesPathParams
	>({
		url: "/subscriptions/{subscriptionId}/invoices",
		method: "get",
		...variables,
	});

export const useGetSubscriptionInvoices = (
	variables: GetSubscriptionInvoicesVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.SubscriptionInvoice,
			GetSubscriptionInvoicesError,
			Schemas.SubscriptionInvoice
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.SubscriptionInvoice,
		GetSubscriptionInvoicesError,
		Schemas.SubscriptionInvoice
	>(
		queryKeyFn({
			path: "/subscriptions/{subscription_id}/invoices",
			operationId: "getSubscriptionInvoices",
			variables,
		}),
		() => fetchGetSubscriptionInvoices({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type GetSubscriptionCancellationReasonsError =
	Fetcher.ErrorWrapper<undefined>;

export type GetSubscriptionCancellationReasonsVariables =
	NapiContext["fetcherOptions"];

export const fetchGetSubscriptionCancellationReasons = (
	variables: GetSubscriptionCancellationReasonsVariables,
) =>
	napiFetch<
		Schemas.SubscriptionCancellationReasons,
		GetSubscriptionCancellationReasonsError,
		undefined,
		{},
		{},
		{}
	>({
		url: "/subscriptions/cancellation_reasons",
		method: "get",
		...variables,
	});

export const useGetSubscriptionCancellationReasons = (
	variables: GetSubscriptionCancellationReasonsVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.SubscriptionCancellationReasons,
			GetSubscriptionCancellationReasonsError,
			Schemas.SubscriptionCancellationReasons
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.SubscriptionCancellationReasons,
		GetSubscriptionCancellationReasonsError,
		Schemas.SubscriptionCancellationReasons
	>(
		queryKeyFn({
			path: "/subscriptions/cancellation_reasons",
			operationId: "getSubscriptionCancellationReasons",
			variables,
		}),
		() =>
			fetchGetSubscriptionCancellationReasons({
				...fetcherOptions,
				...variables,
			}),
		{
			...options,
			...queryOptions,
		},
	);
};

export type CreateSubscriptionPageURLError = Fetcher.ErrorWrapper<
	| {
			status: 400;
			payload: Responses.ValidationErrors;
	  }
	| {
			status: 401;
			payload: Responses.UnauthorizedAccess;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type CreateSubscriptionPageURLVariables = {
	body: Schemas.SubscriptionPageCreation;
} & NapiContext["fetcherOptions"];

/**
 * Create subscription page URL.
 */
export const fetchCreateSubscriptionPageURL = (
	variables: CreateSubscriptionPageURLVariables,
) =>
	napiFetch<
		Schemas.SubscriptionPage,
		CreateSubscriptionPageURLError,
		Schemas.SubscriptionPageCreation,
		{},
		{},
		{}
	>({ url: "/subscription-pages", method: "post", ...variables });

/**
 * Create subscription page URL.
 */
export const useCreateSubscriptionPageURL = (
	options?: Omit<
		reactQuery.UseMutationOptions<
			Schemas.SubscriptionPage,
			CreateSubscriptionPageURLError,
			CreateSubscriptionPageURLVariables
		>,
		"mutationFn"
	>,
) => {
	const { fetcherOptions } = useNapiContext();
	return reactQuery.useMutation<
		Schemas.SubscriptionPage,
		CreateSubscriptionPageURLError,
		CreateSubscriptionPageURLVariables
	>(
		(variables: CreateSubscriptionPageURLVariables) =>
			fetchCreateSubscriptionPageURL({ ...fetcherOptions, ...variables }),
		options,
	);
};

export type FindSubscriptionPlansQueryParams = {
	/*
	 * SDBS licensed product Id
	 *
	 * @format uint64
	 */
	product_id: number;
	/*
	 * Country code. If not provided detected from client IP
	 */
	country?: string;
};

export type FindSubscriptionPlansError = Fetcher.ErrorWrapper<
	| {
			status: 400;
			payload: Responses.ValidationErrors;
	  }
	| {
			status: 401;
			payload: Responses.UnauthorizedAccess;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type FindSubscriptionPlansVariables = {
	queryParams: FindSubscriptionPlansQueryParams;
} & NapiContext["fetcherOptions"];

/**
 * Returns all available subscription plans for provided product and a country.
 */
export const fetchFindSubscriptionPlans = (
	variables: FindSubscriptionPlansVariables,
) =>
	napiFetch<
		Schemas.SubscriptionPricePoints,
		FindSubscriptionPlansError,
		undefined,
		{},
		FindSubscriptionPlansQueryParams,
		{}
	>({ url: "/subscription-plans", method: "get", ...variables });

/**
 * Returns all available subscription plans for provided product and a country.
 */
export const useFindSubscriptionPlans = (
	variables: FindSubscriptionPlansVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.SubscriptionPricePoints,
			FindSubscriptionPlansError,
			Schemas.SubscriptionPricePoints
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.SubscriptionPricePoints,
		FindSubscriptionPlansError,
		Schemas.SubscriptionPricePoints
	>(
		queryKeyFn({
			path: "/subscription-plans",
			operationId: "findSubscriptionPlans",
			variables,
		}),
		() => fetchFindSubscriptionPlans({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type FindSubscriptionProductsError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedAccess;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type FindSubscriptionProductsVariables = NapiContext["fetcherOptions"];

/**
 * Returns all licensed products which are working under subscription license.
 */
export const fetchFindSubscriptionProducts = (
	variables: FindSubscriptionProductsVariables,
) =>
	napiFetch<
		Schemas.SubscriptionProducts,
		FindSubscriptionProductsError,
		undefined,
		{},
		{},
		{}
	>({ url: "/subscription-products", method: "get", ...variables });

/**
 * Returns all licensed products which are working under subscription license.
 */
export const useFindSubscriptionProducts = (
	variables: FindSubscriptionProductsVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.SubscriptionProducts,
			FindSubscriptionProductsError,
			Schemas.SubscriptionProducts
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.SubscriptionProducts,
		FindSubscriptionProductsError,
		Schemas.SubscriptionProducts
	>(
		queryKeyFn({
			path: "/subscription-products",
			operationId: "findSubscriptionProducts",
			variables,
		}),
		() => fetchFindSubscriptionProducts({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type GetAllResourcesError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedApplication;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type GetAllResourcesVariables = NapiContext["fetcherOptions"];

/**
 * Returns all known resources and category memberships, grouped by UPID.
 */
export const fetchGetAllResources = (variables: GetAllResourcesVariables) =>
	napiFetch<
		Schemas.AllResourcesResponse,
		GetAllResourcesError,
		undefined,
		{},
		{},
		{}
	>({ url: "/resources/", method: "get", ...variables });

/**
 * Returns all known resources and category memberships, grouped by UPID.
 */
export const useGetAllResources = (
	variables: GetAllResourcesVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.AllResourcesResponse,
			GetAllResourcesError,
			Schemas.AllResourcesResponse
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.AllResourcesResponse,
		GetAllResourcesError,
		Schemas.AllResourcesResponse
	>(
		queryKeyFn({
			path: "/resources/",
			operationId: "getAllResources",
			variables,
		}),
		() => fetchGetAllResources({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type GetSingleResourcePathParams = {
	rid: string;
};

export type GetSingleResourceError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedApplication;
	  }
	| {
			status: 404;
			payload: Responses.NotFound;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type GetSingleResourceVariables = {
	pathParams: GetSingleResourcePathParams;
} & NapiContext["fetcherOptions"];

/**
 * Returns the Resource with the given `rid`. The `rid` has to be a valid UUID (see [`uuid.UUID`](https://docs.python.org/3/library/uuid.html#uuid.UUID)).
 */
export const fetchGetSingleResource = (variables: GetSingleResourceVariables) =>
	napiFetch<
		Schemas.SingleResourceResponse,
		GetSingleResourceError,
		undefined,
		{},
		{},
		GetSingleResourcePathParams
	>({ url: "/resources/{rid}", method: "get", ...variables });

/**
 * Returns the Resource with the given `rid`. The `rid` has to be a valid UUID (see [`uuid.UUID`](https://docs.python.org/3/library/uuid.html#uuid.UUID)).
 */
export const useGetSingleResource = (
	variables: GetSingleResourceVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.SingleResourceResponse,
			GetSingleResourceError,
			Schemas.SingleResourceResponse
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.SingleResourceResponse,
		GetSingleResourceError,
		Schemas.SingleResourceResponse
	>(
		queryKeyFn({
			path: "/resources/{rid}",
			operationId: "getSingleResource",
			variables,
		}),
		() => fetchGetSingleResource({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type SignUpError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedApplication;
	  }
	| {
			status: 422;
			payload: Responses.ValidationErrors;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type SignUpVariables = {
	body: Schemas.UserSignup;
} & NapiContext["fetcherOptions"];

/**
 * Creates a new user with the given credentials and profile information. Note that this endpoint only requires a valid Application Token for authorization. You don’t have to be authenticated to create a new user, which enables user self-signup from trusted Applications.
 */
export const fetchSignUp = (variables: SignUpVariables) =>
	napiFetch<
		Schemas.SignUpResponse,
		SignUpError,
		Schemas.UserSignup,
		{},
		{},
		{}
	>({ url: "/users/", method: "post", ...variables });

/**
 * Creates a new user with the given credentials and profile information. Note that this endpoint only requires a valid Application Token for authorization. You don’t have to be authenticated to create a new user, which enables user self-signup from trusted Applications.
 */
export const useSignUp = (
	options?: Omit<
		reactQuery.UseMutationOptions<
			Schemas.SignUpResponse,
			SignUpError,
			SignUpVariables
		>,
		"mutationFn"
	>,
) => {
	const { fetcherOptions } = useNapiContext();
	return reactQuery.useMutation<
		Schemas.SignUpResponse,
		SignUpError,
		SignUpVariables
	>(
		(variables: SignUpVariables) =>
			fetchSignUp({ ...fetcherOptions, ...variables }),
		options,
	);
};

export type GetUserLicensesPathParams = {
	/*
	 * NativeID – unique enduser identifier
	 */
	id: string;
};

export type GetUserLicensesQueryParams = {
	/*
	 * if true then list contains also subscribed products
	 *
	 * @default false
	 */
	include_subscriptions?: boolean;
};

export type GetUserLicensesError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedAccess;
	  }
	| {
			status: 404;
			payload: Responses.NotFound;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type GetUserLicensesVariables = {
	pathParams: GetUserLicensesPathParams;
	queryParams?: GetUserLicensesQueryParams;
} & NapiContext["fetcherOptions"];

/**
 * Retrieve list of enduser licenses
 */
export const fetchGetUserLicenses = (variables: GetUserLicensesVariables) =>
	napiFetch<
		Schemas.LicensesResponse,
		GetUserLicensesError,
		undefined,
		{},
		GetUserLicensesQueryParams,
		GetUserLicensesPathParams
	>({ url: "/users/{id}/licenses", method: "get", ...variables });

/**
 * Retrieve list of enduser licenses
 */
export const useGetUserLicenses = (
	variables: GetUserLicensesVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.LicensesResponse,
			GetUserLicensesError,
			Schemas.LicensesResponse
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.LicensesResponse,
		GetUserLicensesError,
		Schemas.LicensesResponse
	>(
		queryKeyFn({
			path: "/users/{id}/licenses",
			operationId: "getUserLicenses",
			variables,
		}),
		() => fetchGetUserLicenses({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type GetMyUserInfoError = Fetcher.ErrorWrapper<
	| {
			status: 400;
			payload: Schemas.ErrorResponse;
	  }
	| {
			status: 401;
			payload: Responses.UnauthorizedAccess;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type GetMyUserInfoVariables = NapiContext["fetcherOptions"];

/**
 * Returns the profile information associated with the authenticated user. The user is derived from the Access Token specified in the Request Header.
 */
export const fetchGetMyUserInfo = (variables: GetMyUserInfoVariables) =>
	napiFetch<
		Schemas.GetUsersMeResponse,
		GetMyUserInfoError,
		undefined,
		{},
		{},
		{}
	>({ url: "/users/me", method: "get", ...variables });

/**
 * Returns the profile information associated with the authenticated user. The user is derived from the Access Token specified in the Request Header.
 */
export const useGetMyUserInfo = (
	variables: GetMyUserInfoVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.GetUsersMeResponse,
			GetMyUserInfoError,
			Schemas.GetUsersMeResponse
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.GetUsersMeResponse,
		GetMyUserInfoError,
		Schemas.GetUsersMeResponse
	>(
		queryKeyFn({ path: "/users/me", operationId: "getMyUserInfo", variables }),
		() => fetchGetMyUserInfo({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type UpdateMyCredentialsError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedAccess;
	  }
	| {
			status: 422;
			payload: Responses.ValidationErrors;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type UpdateMyCredentialsVariables = {
	body?: Schemas.UsersMeInputMessage;
} & NapiContext["fetcherOptions"];

/**
 * Updates the users profile with a given new username or password. The view will not permit both to be updated in one request. Perform same password validation as on account creation.
 */
export const fetchUpdateMyCredentials = (
	variables: UpdateMyCredentialsVariables,
) =>
	napiFetch<
		Schemas.UsersMeResponse,
		UpdateMyCredentialsError,
		Schemas.UsersMeInputMessage,
		{},
		{},
		{}
	>({ url: "/users/me", method: "put", ...variables });

/**
 * Updates the users profile with a given new username or password. The view will not permit both to be updated in one request. Perform same password validation as on account creation.
 */
export const useUpdateMyCredentials = (
	options?: Omit<
		reactQuery.UseMutationOptions<
			Schemas.UsersMeResponse,
			UpdateMyCredentialsError,
			UpdateMyCredentialsVariables
		>,
		"mutationFn"
	>,
) => {
	const { fetcherOptions } = useNapiContext();
	return reactQuery.useMutation<
		Schemas.UsersMeResponse,
		UpdateMyCredentialsError,
		UpdateMyCredentialsVariables
	>(
		(variables: UpdateMyCredentialsVariables) =>
			fetchUpdateMyCredentials({ ...fetcherOptions, ...variables }),
		options,
	);
};

export type GetMyProductsQueryParams = {
	/*
	 * if true then list contains also subscribed products
	 *
	 * @default false
	 */
	include_subscriptions?: boolean;
};

export type GetMyProductsError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedAccess;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type GetMyProductsVariables = {
	queryParams?: GetMyProductsQueryParams;
} & NapiContext["fetcherOptions"];

export const fetchGetMyProducts = (variables: GetMyProductsVariables) =>
	napiFetch<
		Schemas.MyProductsResponse,
		GetMyProductsError,
		undefined,
		{},
		GetMyProductsQueryParams,
		{}
	>({ url: "/users/me/products", method: "get", ...variables });

export const useGetMyProducts = (
	variables: GetMyProductsVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.MyProductsResponse,
			GetMyProductsError,
			Schemas.MyProductsResponse
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.MyProductsResponse,
		GetMyProductsError,
		Schemas.MyProductsResponse
	>(
		queryKeyFn({
			path: "/users/me/products",
			operationId: "getMyProducts",
			variables,
		}),
		() => fetchGetMyProducts({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type AddMyProductError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedAccess;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type AddMyProductVariables = {
	body: Schemas.RegisterProductRequest;
} & NapiContext["fetcherOptions"];

/**
 * Registers a new serial into the user’s account.
 */
export const fetchAddMyProduct = (variables: AddMyProductVariables) =>
	napiFetch<
		Schemas.RegisterProductResponse,
		AddMyProductError,
		Schemas.RegisterProductRequest,
		{},
		{},
		{}
	>({ url: "/users/me/products", method: "post", ...variables });

/**
 * Registers a new serial into the user’s account.
 */
export const useAddMyProduct = (
	options?: Omit<
		reactQuery.UseMutationOptions<
			Schemas.RegisterProductResponse,
			AddMyProductError,
			AddMyProductVariables
		>,
		"mutationFn"
	>,
) => {
	const { fetcherOptions } = useNapiContext();
	return reactQuery.useMutation<
		Schemas.RegisterProductResponse,
		AddMyProductError,
		AddMyProductVariables
	>(
		(variables: AddMyProductVariables) =>
			fetchAddMyProduct({ ...fetcherOptions, ...variables }),
		options,
	);
};

export type GetProductDifferencesQueryParams = {
	/*
	 * licensed product to compare
	 *
	 * @example 2173
	 */
	licensed_product_id: number;
};

export type GetProductDifferencesError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedAccess;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type GetProductDifferencesVariables = {
	queryParams: GetProductDifferencesQueryParams;
} & NapiContext["fetcherOptions"];

export const fetchGetProductDifferences = (
	variables: GetProductDifferencesVariables,
) =>
	napiFetch<
		Schemas.ProductDifferencesResponse,
		GetProductDifferencesError,
		undefined,
		{},
		GetProductDifferencesQueryParams,
		{}
	>({ url: "/users/me/product_differences", method: "get", ...variables });

export const useGetProductDifferences = (
	variables: GetProductDifferencesVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.ProductDifferencesResponse,
			GetProductDifferencesError,
			Schemas.ProductDifferencesResponse
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.ProductDifferencesResponse,
		GetProductDifferencesError,
		Schemas.ProductDifferencesResponse
	>(
		queryKeyFn({
			path: "/users/me/product_differences",
			operationId: "getProductDifferences",
			variables,
		}),
		() => fetchGetProductDifferences({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type GetMySubscriptionsError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedAccess;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type GetMySubscriptionsVariables = NapiContext["fetcherOptions"];

export const fetchGetMySubscriptions = (
	variables: GetMySubscriptionsVariables,
) =>
	napiFetch<
		Schemas.MySubscriptionsResponse,
		GetMySubscriptionsError,
		undefined,
		{},
		{},
		{}
	>({ url: "/users/me/subscriptions", method: "get", ...variables });

export const useGetMySubscriptions = (
	variables: GetMySubscriptionsVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.MySubscriptionsResponse,
			GetMySubscriptionsError,
			Schemas.MySubscriptionsResponse
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.MySubscriptionsResponse,
		GetMySubscriptionsError,
		Schemas.MySubscriptionsResponse
	>(
		queryKeyFn({
			path: "/users/me/subscriptions",
			operationId: "getMySubscriptions",
			variables,
		}),
		() => fetchGetMySubscriptions({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type GetMyProductUpgradePathsError = Fetcher.ErrorWrapper<
	| {
			status: 401;
			payload: Responses.UnauthorizedAccess;
	  }
	| {
			status: 500;
			payload: Responses.InternalError;
	  }
>;

export type GetMyProductUpgradePathsVariables = NapiContext["fetcherOptions"];

export const fetchGetMyProductUpgradePaths = (
	variables: GetMyProductUpgradePathsVariables,
) =>
	napiFetch<
		Schemas.ProductUpgradePathsResponse,
		GetMyProductUpgradePathsError,
		undefined,
		{},
		{},
		{}
	>({ url: "/users/me/upgrade_paths", method: "get", ...variables });

export const useGetMyProductUpgradePaths = (
	variables: GetMyProductUpgradePathsVariables,
	options?: Omit<
		reactQuery.UseQueryOptions<
			Schemas.ProductUpgradePathsResponse,
			GetMyProductUpgradePathsError,
			Schemas.ProductUpgradePathsResponse
		>,
		"queryKey" | "queryFn"
	>,
) => {
	const { fetcherOptions, queryOptions, queryKeyFn } = useNapiContext(options);
	return reactQuery.useQuery<
		Schemas.ProductUpgradePathsResponse,
		GetMyProductUpgradePathsError,
		Schemas.ProductUpgradePathsResponse
	>(
		queryKeyFn({
			path: "/users/me/upgrade_paths",
			operationId: "getMyProductUpgradePaths",
			variables,
		}),
		() => fetchGetMyProductUpgradePaths({ ...fetcherOptions, ...variables }),
		{
			...options,
			...queryOptions,
		},
	);
};

export type QueryOperation =
	| {
			path: "/supporters/serial_number_exports";
			operationId: "exportSerialNumbers";
			variables: ExportSerialNumbersVariables;
	  }
	| {
			path: "/supporters/users/{id}";
			operationId: "getUser";
			variables: GetUserVariables;
	  }
	| {
			path: "/supporters/users/{id}/licensedproducts";
			operationId: "getUserLicensedProducts";
			variables: GetUserLicensedProductsVariables;
	  }
	| {
			path: "/supporters/licensedproducts";
			operationId: "getAllLicensedProducts";
			variables: GetAllLicensedProductsVariables;
	  }
	| {
			path: "/supporters/users/{id}/registrations";
			operationId: "getUserRegistrations";
			variables: GetUserRegistrationsVariables;
	  }
	| {
			path: "/configurations/";
			operationId: "getConfiguration";
			variables: GetConfigurationVariables;
	  }
	| {
			path: "/configurations/{group}";
			operationId: "getConfigurationGroup";
			variables: GetConfigurationGroupVariables;
	  }
	| {
			path: "/base/ping";
			operationId: "ping";
			variables: PingVariables;
	  }
	| {
			path: "/base/crash";
			operationId: "crash";
			variables: CrashVariables;
	  }
	| {
			path: "/base/ping_sdbs";
			operationId: "pingSdbs";
			variables: PingSdbsVariables;
	  }
	| {
			path: "/base/ping_rabbitmq";
			operationId: "pingRabbitmq";
			variables: PingRabbitmqVariables;
	  }
	| {
			path: "/changelogs/{upid}";
			operationId: "getCompleteChangelog";
			variables: GetCompleteChangelogVariables;
	  }
	| {
			path: "/changelogs/{upid}/{from_version}/{to_version}";
			operationId: "getPartialChangelog";
			variables: GetPartialChangelogVariables;
	  }
	| {
			path: "/download/full-products/{upid}";
			operationId: "downloadProduct";
			variables: DownloadProductVariables;
	  }
	| {
			path: "/download/me/full-products";
			operationId: "getMyFullProductsDownloads";
			variables: GetMyFullProductsDownloadsVariables;
	  }
	| {
			path: "/download/updates/{upid}";
			operationId: "downloadProductUpdates";
			variables: DownloadProductUpdatesVariables;
	  }
	| {
			path: "/download/me/updates";
			operationId: "getMyProductUpdatesDownloads";
			variables: GetMyProductUpdatesDownloadsVariables;
	  }
	| {
			path: "/download/me/content";
			operationId: "getMyProductContentDownloads";
			variables: GetMyProductContentDownloadsVariables;
	  }
	| {
			path: "/download/players/{upid}";
			operationId: "downloadPlayer";
			variables: DownloadPlayerVariables;
	  }
	| {
			path: "/download/links/{upid}/{file_id}";
			operationId: "downloadLinks";
			variables: DownloadLinksVariables;
	  }
	| {
			path: "/products/";
			operationId: "getProducts";
			variables: GetProductsVariables;
	  }
	| {
			path: "/products/{upid}";
			operationId: "getSingleProduct";
			variables: GetSingleProductVariables;
	  }
	| {
			path: "/products/categories";
			operationId: "getProductCategories";
			variables: GetProductCategoriesVariables;
	  }
	| {
			path: "/subscriptions/{subscription_id}";
			operationId: "getSubscriptionDetails";
			variables: GetSubscriptionDetailsVariables;
	  }
	| {
			path: "/subscriptions/bundles";
			operationId: "getSubscriptionBundles";
			variables: GetSubscriptionBundlesVariables;
	  }
	| {
			path: "/subscriptions/users/{native_id}";
			operationId: "getUsersSubscriptionInformation";
			variables: GetUsersSubscriptionInformationVariables;
	  }
	| {
			path: "/subscriptions/{subscription_id}/invoices";
			operationId: "getSubscriptionInvoices";
			variables: GetSubscriptionInvoicesVariables;
	  }
	| {
			path: "/subscriptions/cancellation_reasons";
			operationId: "getSubscriptionCancellationReasons";
			variables: GetSubscriptionCancellationReasonsVariables;
	  }
	| {
			path: "/subscription-plans";
			operationId: "findSubscriptionPlans";
			variables: FindSubscriptionPlansVariables;
	  }
	| {
			path: "/subscription-products";
			operationId: "findSubscriptionProducts";
			variables: FindSubscriptionProductsVariables;
	  }
	| {
			path: "/resources/";
			operationId: "getAllResources";
			variables: GetAllResourcesVariables;
	  }
	| {
			path: "/resources/{rid}";
			operationId: "getSingleResource";
			variables: GetSingleResourceVariables;
	  }
	| {
			path: "/users/{id}/licenses";
			operationId: "getUserLicenses";
			variables: GetUserLicensesVariables;
	  }
	| {
			path: "/users/me";
			operationId: "getMyUserInfo";
			variables: GetMyUserInfoVariables;
	  }
	| {
			path: "/users/me/products";
			operationId: "getMyProducts";
			variables: GetMyProductsVariables;
	  }
	| {
			path: "/users/me/product_differences";
			operationId: "getProductDifferences";
			variables: GetProductDifferencesVariables;
	  }
	| {
			path: "/users/me/subscriptions";
			operationId: "getMySubscriptions";
			variables: GetMySubscriptionsVariables;
	  }
	| {
			path: "/users/me/upgrade_paths";
			operationId: "getMyProductUpgradePaths";
			variables: GetMyProductUpgradePathsVariables;
	  };

/**
 * Generated by @openapi-codegen
 *
 * @version 1.85.0
 */
export type ResponseHead = {
	api_version: string;
	id: string;
	status: string;
};

export type ResponseHeadWithErrors = ResponseHead & {
	error_message?: {
		error?: Error;
		field_errors?: {
			error?: Error;
			field?: string;
		}[];
	};
};

export type UserSignup = {
	email: string;
	email_repeat: string;
	password: string;
	password_repeat: string;
	first_name?: string;
	last_name?: string;
	country: string;
	language: string;
};

export type Credentials = {
	/*
	 * Username
	 */
	username: string;
	/*
	 * password of the user
	 *
	 * @format password
	 */
	password: string;
};

export type Token = {
	/*
	 * Contents of the token
	 */
	token?: string;
	/*
	 * @format long
	 */
	valid_until?: number;
};

/**
 * Subscription details if activation token was created for subscribable product.
 */
export type SubscriptionInToken = {
	/*
	 * Subscription ID
	 */
	subscription_id: number;
	/*
	 * Subscription ID of external subscription provider
	 */
	external_subscription_id: string;
	/*
	 * Subscription status
	 *
	 * @example active
	 */
	status: "trial" | "active" | "cancelled" | "paused";
	/*
	 * Date of subscription creation
	 *
	 * @format date-time
	 */
	created_at: string;
	/*
	 * Date of last subscription update
	 *
	 * @format date-time
	 */
	updated_at: string;
	/*
	 * Date of subscription cycle start
	 *
	 * @format date-time
	 */
	started_at: string;
	/*
	 * Date of subscription cycle end
	 *
	 * @format date-time
	 */
	end_at: string;
	/*
	 * Seconds to subscription expiration
	 */
	expires_in: number;
	/*
	 * Date when subscription will be cancelled, optional.
	 *
	 * @format date-time
	 */
	cancellation_scheduled_at?: string;
	/*
	 * Seconds added in subscription end_at and used in expiration calculations, optional.
	 */
	grace_period?: number;
};

export type Subscription = {
	/*
	 * Subscription ID
	 */
	subscription_id: number;
	/*
	 * Subscription ID of external subscription provider
	 */
	external_subscription_id: string;
	/*
	 * Subscription status
	 *
	 * @example active
	 */
	status: "trial" | "active" | "cancelled" | "paused";
	/*
	 * Date of subscription creation
	 *
	 * @format date-time
	 */
	created_at: string;
	/*
	 * Date of last subscription update
	 *
	 * @format date-time
	 */
	updated_at: string;
	/*
	 * Date of subscription cycle start
	 *
	 * @format date-time
	 */
	started_at: string;
	/*
	 * Date of subscription cycle end
	 *
	 * @format date-time
	 */
	end_at: string;
	/*
	 * Seconds to subscription expiration
	 */
	expires_in: number;
	/*
	 * Date when subscription will be cancelled, optional.
	 *
	 * @format date-time
	 */
	cancellation_scheduled_at?: string;
	product: SubscribedProduct;
	licensed_product?: SubscribedLicensedProduct;
};

export type SubscriptionCreation = {
	/*
	 * Subscription ID of external subscription provider
	 */
	external_subscription_id?: string;
};

export type SubscriptionUserInfo = {
	billing_address?: {
		/*
		 * First Name of subscription's billing address
		 */
		first_name?: string;
		/*
		 * Last name of subscription's billing address
		 */
		last_name?: string;
		/*
		 * Billing address
		 */
		address?: string;
		/*
		 * Billing address city
		 */
		city?: string;
		/*
		 * Billing address state
		 */
		state?: string;
		/*
		 * Zip Code of billing address
		 */
		zip_code?: string;
	};
};

export type SubscriptionInvoice = {
	/*
	 * Link to download Invoice
	 */
	link?: string;
	/*
	 * Date of invoice
	 */
	date?: number;
	/*
	 * Due date of invoice
	 */
	due_date?: number;
	/*
	 * Ammount paid
	 */
	ammount_paid?: string;
}[];

export type SubscriptionCancellationReasons = {
	/*
	 * Cancellation reason code
	 */
	reason_code?: string;
	/*
	 * Complete display name of the cancellation reason code
	 */
	display_name?: string;
	/*
	 * Order in which these will be displayed
	 */
	order_id?: number;
}[];

/**
 * response of /subscription-plans
 */
export type SubscriptionPricePoints = {
	response_head?: ResponseHead;
	response_body?: {
		price_points?: SubscriptionPricePoint[];
	};
};

export type SubscriptionPricePoint = {
	/*
	 * Price point ID.
	 */
	item_price_id?: string;
	/*
	 * Title of the price point in external subscription service.
	 */
	system_title?: string;
	/*
	 * Price point currency.
	 */
	currency?: string;
	/*
	 * Cycle of the subscription price point.
	 */
	period?: number;
	/*
	 * Cycle unit, for example: month, year, day.
	 */
	period_unit?: string;
	/*
	 * Price for subscription cycle.
	 */
	price?: string;
};

/**
 * response of /subscription-products
 */
export type SubscriptionProducts = {
	response_head?: ResponseHead;
	response_body?: SubscriptionProduct[];
};

export type SubscriptionProduct = {
	/*
	 * Licensed Product ID.
	 */
	id?: number;
	/*
	 * Licensed product title.
	 */
	title?: string;
	/*
	 * Product which was licensed with subscription.
	 */
	product?: ProductBasicData;
	/*
	 * List of price points for this licensed product.
	 */
	price_points?: SubscriptionPricePoint[];
	/*
	 * List of licensed products required to be own by enduser to be enabled for this subscription.
	 */
	extension_to?: SubscriptionExtensionItem[];
};

export type SubscriptionExtensionItem = {
	/*
	 * Licensed Product ID.
	 */
	id?: number;
	/*
	 * Licensed product title.
	 */
	title?: string;
};

export type SubscriptionStatus = {
	/*
	 * Status of the subscription
	 */
	status?: "active" | "paused";
};

export type SubscriptionCancellationStatus = {
	/*
	 * Status of the subscription
	 */
	status?: "cancelled";
	/*
	 * Reason why the subscription is cancelled. This is defined by the reason codes in Chargebee Admin UI
	 */
	cancellation_reason?: string;
	/*
	 * Extra comment of the user about change of status
	 */
	extra_comment?: string;
};

export type SubscriptionPageCreation = {
	/*
	 * Type of the subscription page to be requested.
	 */
	type: "checkout" | "management" | "payment_methods";
	/*
	 * Only for the checkout type. SDBS licensed product ID. Required if type='checkout'.
	 */
	product_id?: string;
	/*
	 * Only for the checkout type. Redirect URL to which external subscription service will do redirection after purchase.
	 */
	redirect_url?: string;
	/*
	 * Only for the checkout type. Payment currency, if not provided detected from customer country stored in account profile.
	 */
	currency_code?: string;
	/*
	 * Only for the checkout type. Subscription cycle, default: month
	 */
	period_unit?: string;
	/*
	 * Only for the checkout type. Billing address first name, default: first name from enduser account profile.
	 */
	billing_first_name?: string;
	/*
	 * Only for the checkout type. Billing address last name, default: surname from enduser account profile.
	 */
	billing_last_name?: string;
	/*
	 * Only for the checkout type. Billing address street.
	 */
	billing_line1?: string;
	/*
	 * Only for the checkout type. Billing address city.
	 */
	billing_city?: string;
	/*
	 * Only for the checkout type. Billing address state.
	 */
	billing_state?: string;
	/*
	 * Only for the checkout type. Billing address zip.
	 */
	billing_zip?: string;
	/*
	 * Only for the checkout type. Billing address country iso code, default: country from enduser account profile.
	 */
	billing_country?: string;
	/*
	 * Only for the checkout type. Price point for product subscription (taken from external subscription service), by default determined from currency_code and period_unit.
	 */
	item_price_id?: string;
	/*
	 * Only for the checkout type. Preferable language of checkout form, expect iso code. Default: SDBS enduser language.
	 */
	language?: string;
};

export type SubscriptionPage = {
	/*
	 * URL for subscription purchase.
	 */
	subscription_page_url?: string;
};

/**
 * Subscribed product basic data.
 */
export type SubscribedProduct = {
	/*
	 * Unique identifier representing a specific product
	 */
	upid?: string;
	/*
	 * serial number of product.
	 */
	serial_number?: string;
	/*
	 * product title.
	 */
	title?: string;
};

/**
 * Basic information about product.
 */
export type ProductBasicData = {
	/*
	 * SDBS Product ID
	 */
	id?: number;
	/*
	 * Unique identifier representing a specific product
	 */
	upid?: string;
	/*
	 * product title.
	 */
	title?: string;
};

/**
 * Subscribed licensed product basic data.
 */
export type SubscribedLicensedProduct = {
	/*
	 * Unique identifier representing a specific licensed product (SDBS ID)
	 */
	id?: number;
	/*
	 * Licensed product title.
	 */
	title?: string;
};

export type Product = {
	/*
	 * Unique identifier representing a specific product
	 */
	upid?: string;
	/*
	 * serial number of product.
	 */
	serial_number?: string;
	/*
	 * registration date name of product.
	 *
	 * @format long
	 */
	registration_date?: number;
	/*
	 * product title.
	 */
	title?: string;
	/*
	 * Product on a subscription
	 */
	subscribed?: boolean;
};

export type Category = {
	/*
	 * Category id
	 */
	id?: string;
	/*
	 * Category Name
	 */
	name?: string;
	/*
	 * Id of category's parent (used for only subcategories)
	 */
	parent_id?: string;
	/*
	 * Category sorting priority
	 */
	sort_order?: number;
};

export type CategoryResponse = {
	response_head?: ResponseHead;
	response_body?: {
		categories?: Category[];
	};
};

export type ProductResponseObject = {
	/*
	 * Identifier of the product
	 */
	upid?: string;
};

/**
 * Licensed product information
 */
export type LicensedProductObject = {
	/*
	 * Name of the licensed product
	 */
	title?: string;
	/*
	 * Licensed product ID
	 */
	id?: number;
};

export type SubscriptionBundle = {
	licensed_product?: LicensedProductObject;
};

export type SubscriptionBundleResponse = {
	response_head?: ResponseHead;
	response_body?: {
		bundles?: SubscriptionBundle[];
	};
};

export type ProductResponse = {
	response_head: ResponseHead;
	response_body: {
		products: ProductResponseObject[];
	};
};

export type Resource = {
	/*
	 * Id of Resource
	 */
	resource_id: string;
	/*
	 * Key of resource
	 */
	key: string;
	/*
	 * MD5 checksum of resource
	 */
	md5: string;
	/*
	 * type of resource
	 */
	type: string;
	/*
	 * value of resource
	 */
	value: string;
};

export type ProductWithResource = {
	upid: string;
	categories?: string[];
	resources?: Resource[];
};

export type ProductByUpidResponse = {
	response_head: ResponseHead;
	response_body: ProductWithResource;
};

/**
 * response of /auth/token
 */
export type AuthTokenResponse = {
	response_head: ResponseHead;
	response_body: {
		access: Token;
		refresh: Token;
		/*
		 * user id from the authentication service
		 */
		user_id: string;
	};
};

/**
 * response of /users/me/products
 */
export type MyProductsResponse = {
	response_head: ResponseHead;
	response_body: {
		products: Product[];
	};
};

/**
 * response of /users/me/subscription
 */
export type MySubscriptionsResponse = {
	response_head?: ResponseHead;
	response_body?: {
		subscriptions?: Subscription[];
	};
};

export type License = {
	/*
	 * Unique identifier representing a licensed product
	 */
	licensedproduct_id?: number;
	/*
	 * Serial number of product.
	 */
	serial_number?: string;
	/*
	 * Licensed product title.
	 */
	licensedproduct_title?: string;
	/*
	 * Serial prefix of product.
	 */
	serialprefix?: string;
	/*
	 * Registration date of product.
	 *
	 * @format date-time
	 */
	registration_date?: string;
	/*
	 * License class.
	 */
	licenseclass?: string;
	/*
	 * License transfer type.
	 */
	transfer_type?: string;
	/*
	 * License transfer token.
	 */
	transfer_token?: string;
	/*
	 * Unique identifier representing a specific product
	 */
	product_upid?: string;
	/*
	 * Registration id used for license transfer.
	 */
	registration_id?: number;
};

/**
 * response of /users/{id}/licenses
 */
export type LicensesResponse = {
	response_head: ResponseHead;
	response_body: {
		licenses: License[];
	};
};

/**
 * response of /users/
 */
export type SignUpResponse = {
	response_head: ResponseHead;
	response_body: {
		user_id: string;
		tokens: {
			access: Token;
			refresh: Token;
		};
	};
};

export type Error = {
	id: string;
	message: string;
	target: "DEV" | "USER";
};

/**
 * what errors look like
 */
export type ErrorResponse = {
	response_head: ResponseHeadWithErrors;
};

/**
 * User object with all optional fields
 */
export type UsersMeInputMessage = {
	username?: string;
	password?: string;
	firstname?: string;
	lastname?: string;
	country?: string;
	language?: string;
};

/**
 * Response containing server message
 */
export type UsersMeResponse = {
	response_head: ResponseHead;
	response_body: {
		message?: string;
	};
};

export type RegisterProductRequest = {
	serial: string;
};

export type RegisterProductResponse = {
	response_head: ResponseHead;
	response_body: Record<string, any>;
};

export type CompleteChangelogResult = {
	response_head: ResponseHead;
	response_body: {
		changelog?: {
			upid?: string;
			html?: string;
		};
	};
};

export type ConfigurationResponse = {
	response_head: ResponseHead;
	response_body: {
		config: {
			key?: string;
			value?: string;
			group?: string;
		}[];
	};
};

export type SerialNumberExportsResponse = {
	response_head: ResponseHead;
	response_body: {
		product_id: number;
		product_title: string;
		product_upid: string;
		serial_numbers: {
			normal_serial?: string;
			serial_number?: string;
			serial_reference?: string;
		}[];
	};
};

/**
 * | enum key        | int |
 * | ---------------:|:---:|
 * | RAS2            |  0  |
 * | RAS3            |  1  |
 *
 * @minimum 0
 * @maximum 1
 */
export type ActivationMethod = number;

export type ActivationError = {
	id: string;
	target?: "DEV" | "USER";
	message?: string;
	args?: {
		key: string;
		value: string;
	}[];
};

export type ActivationRequest = {
	request_list?: {
		serial: string;
		system_id: string;
	}[];
	method?: ActivationMethod;
};

export type ActivationResponse = {
	response_head: ResponseHead;
	response_body: {
		response_list?: {
			serial: string;
			result?: string;
			error?: ActivationError;
		}[];
		method?: ActivationMethod;
	};
};

export type AllResourcesResponse = {
	response_head: ResponseHead;
	response_body: {
		mappings?: ProductWithResource[];
	};
};

export type SingleResourceResponse = {
	response_head: ResponseHead;
	response_body: {
		resource: Resource;
	};
};

/**
 * | enum key        | int |
 * | ---------------:|:---:|
 * | unknown_type    |  0  |
 * | installer_type  |  2  |
 * | iso_type        |  4  |
 * | downloader_type |  7  |
 *
 * @minimum 0
 * @maximum 7
 */
export type DownloadFileType = number;

/**
 * | enum key             | int |
 * | --------------------:|:---:|
 * | download_dir         |  0  |
 *
 * @minimum 0
 * @maximum 3
 */
export type DownloadTargetDir = number;

/**
 * | enum key              | int |
 * | ---------------------:|:---:|
 * | unknown_platform      |  0  |
 * | pc_platform           |  1  |
 * | mac_platform          |  2  |
 * | all_platform          |  3  |
 * | linux_x86_64_platform |  4  |
 * | nativeos_platform     |  5  |
 *
 * @minimum 0
 * @maximum 4
 */
export type DownloadPlatform = number;

/**
 * | enum key            | int |
 * | -------------------:|:---:|
 * | any_platform        |  0  |
 * | mas_x86_64_platform |  1  |
 *
 * @minimum 0
 * @maximum 4
 */
export type DownloadHardwarePlatform = number;

/**
 * | enum key              | int |
 * | ---------------------:|:---:|
 * | unknown_type          |  0  |
 * | update_type           |  1  |
 * | new_product_type      |  3  |
 * | player_type           |  7  |
 *
 * @minimum 0
 * @maximum 7
 */
export type DownloadArtifactType = number;

export type DownloadFile = {
	target_file: string;
	target_dir: DownloadTargetDir;
	/*
	 * @format uint64
	 */
	filesize: number;
	type: DownloadFileType;
	url: string;
};

export type DownloadArtifact = {
	info?: string;
	os_min?: string;
	os_max?: string;
	title: string;
	release_date: string;
	upid: string;
	platform: DownloadPlatform;
	hardware_platform?: DownloadHardwarePlatform;
	version: string;
	update_id: string;
	type: DownloadArtifactType;
	files?: DownloadFile[];
};

export type DownloadUnavailableProduct = {
	upid?: string;
	message?: string;
	reason?: "none" | "os_incompatible";
};

export type DownloadProductsResponse = {
	response_head: ResponseHead;
	response_body: {
		artifacts?: DownloadArtifact[];
		unavailable?: DownloadUnavailableProduct[];
	};
};

export type DownloadProductsResponseLegacy = {
	response_head: ResponseHead;
	response_body: {
		artifacts?: DownloadArtifact[];
	};
};

export type ProductUpgradePathItem = {
	/*
	 * SDBS primary key of licensed product.
	 *
	 * @example 232
	 */
	licensedproduct_id?: number;
	/*
	 * Title of licensed product.
	 *
	 * @example ABSYNTH 2
	 */
	title?: string;
	/*
	 * License type attached to licensed product.
	 *
	 * @example full
	 */
	license_type?: string;
};

export type ProductUpgradePath = {
	/*
	 * SDBS primary key of licensed product.
	 *
	 * @example 181
	 */
	licensedproduct_id: number;
	/*
	 * Title of licensed product.
	 *
	 * @example ABSYNTH
	 */
	title: string;
	/*
	 * Flag indicating if product is registered (true) or ready for download (false).
	 *
	 * @example true
	 */
	registered: boolean;
	/*
	 * Flag indicating if licensed product is bundle or not.
	 *
	 * @example false
	 */
	bundle: boolean;
	/*
	 * License type attached to licensed product.
	 *
	 * @example full
	 */
	license_type: string;
	/*
	 * License class attached to licensed product.
	 *
	 * @example COM
	 */
	license_class: string;
	/*
	 * List of products which can be purchased to upgrade to higher or other related products.
	 */
	upgrade_path: ProductUpgradePathItem[];
};

export type ProductUpgradePathsResponse = {
	response_head: ResponseHead;
	response_body: ProductUpgradePath[];
};

export type ProductDifferencesItem = {
	/*
	 * SDBS primary key of licensed product.
	 *
	 * @example 232
	 */
	licensedproduct_id?: number;
	/*
	 * Title of licensed product.
	 *
	 * @example ABSYNTH 2
	 */
	title?: string;
	/*
	 * License type attached to licensed product.
	 *
	 * @example full
	 */
	license?: string;
	/*
	 * Product unique identifier
	 */
	upid?: string;
};

export type ProductDifferencesResponse = {
	response_head: ResponseHead;
	response_body: ProductDifferencesItem[];
};

export type LicenseTransferRequest = {
	licenses?: {
		license_id?: string;
	}[];
};

export type LicenseTransferResponse = {
	response_head: ResponseHead;
	response_body: {
		job?: {
			job_id?: string;
		};
	};
};

export type GetUsersMeResponse = {
	response_head: ResponseHead;
	response_body: {
		user_id?: string;
		first_name?: string;
		last_name?: string;
		country?: string;
		language?: string;
		username?: string;
		email_verified?: boolean;
		ecommerce_status?: "new" | "returning" | "unknown";
	};
};

export type Enduser = {
	response_head: ResponseHead;
	response_body: {
		/*
		 * @example 5fa940fd802e6600681f1c18
		 */
		native_id: string;
		email: string;
		first_name: string;
		last_name: string;
		/*
		 * SDBS-specific id, not to be used in new systems
		 *
		 * @deprecated true
		 * @example 283
		 */
		sdbs_id?: number;
		language: Language;
		country: Country;
		/*
		 * @format date-time
		 */
		created_at?: string;
		/*
		 * @format date-time
		 */
		updated_at?: string;
		locked?: boolean;
		/*
		 * Source for user registration. Formerly "Origin"
		 *
		 * @example sounds.com
		 */
		creation_source?: string;
		addresses?: Address[];
	};
};

/**
 * Used for identification of clients. Can be created in the API (manually).
 */
export type ApplicationToken = {
	/*
	 * @example application
	 */
	sub?: string;
	/*
	 * @format uint64
	 */
	iat?: number;
	/*
	 * @format uint64
	 */
	exp?: number;
	data?: {
		/*
		 * @example 2.3.0
		 */
		version?: string;
		/*
		 * @example My App
		 */
		name?: string;
	};
};

/**
 * Corresponds to a session, can be valid for 60 min or 24 hours. Is issued by
 * the API on authentication.
 *
 * Retrieving the native-id (user-id) from the token can be
 * done without signature verification. It is however recommended that the user information
 * and native-id are read using the Get Userdata. This can information on whether
 * an account is active by passing the access token.
 */
export type OAuth2TokenSDBS = {
	/*
	 * @example access
	 */
	sub?: string;
	/*
	 * @example sdbs-stage11.ext.native-instruments.de-1563274387
	 */
	iss?: string;
	/*
	 * @format uint64
	 */
	iat?: number;
	/*
	 * @format uint64
	 */
	exp?: number;
	data?: {
		/*
		 * @format UUID
		 */
		["native-id"]?: string;
	};
	nbf?: number;
};

/**
 * Corresponds to a session, can be valid for 60 min or 24 hours. Is issued by
 * the API on authentication.
 *
 * Retrieving the native-id (user-id) from the token can be
 * done without signature verification. It is however recommended that the user information
 * and native-id are read using the Get Userdata. This can information on whether
 * an account is active by passing the access token.
 */
export type OAuth2TokenAuth0 = {
	/*
	 * @example sdbs-stage11.ext.native-instruments.de-1563274387
	 */
	iss?: string;
	/*
	 * @example auth0|1289e6c4-a1a2-4487-9632-553cf725748b
	 */
	sub?: string;
	/*
	 * @example https://native-test.eu.auth0.com/api/v2/
	 */
	aud?: string;
	/*
	 * @format uint64
	 */
	iat?: number;
	/*
	 * @format uint64
	 */
	exp?: number;
	azp?: string;
	/*
	 * @example read:current_user update:current_user_metadata delete:current_user_metadata create:current_user_metadata create:current_user_device_credentials delete:current_user_device_credentials update:current_user_identities offline_access
	 */
	scope?: string;
	data?: {
		/*
		 * @format UUID
		 */
		["native-id"]?: string;
	};
	nbf?: number;
};

/**
 * JWT Header
 */
export type RAS3Header = {
	/*
	 * @example RS256
	 */
	alg?: string;
	/*
	 * @example myKeyId
	 */
	kid?: string;
	/*
	 * @example ni-ras3
	 */
	typ?: string;
};

/**
 * JWT Payload
 */
export type RAS3TokenPayload = {
	/*
	 * Time the token was issued.
	 *
	 * @format uint64
	 */
	iat?: number;
	/*
	 * A RAS3 serial number.
	 *
	 * @example ABCDDE-serial
	 */
	serial?: string;
	/*
	 * The user-id in UUID4 format.
	 *
	 * @format uuid
	 */
	["native-id"]?: string;
	/*
	 * A Base64 encoded JSON object describing the hardware the token is tied to (Note: this uses the normal Base64 encoding, not the JWT dialect of Base64).
	 *
	 * @format byte
	 */
	hardware_profile?: string;
	/*
	 * Subject, always "activation".
	 *
	 * @example activation
	 */
	sub?: string;
	/*
	 * The expiration time after which the token becomes invalid.
	 *
	 * @format uint64
	 */
	exp?: number;
	subscription?: SubscriptionInToken;
};

/**
 * The hardware profile is a JSON object with the following fields.
 */
export type RAS3HardwareProfile = {
	/*
	 * Number of logical cores.
	 *
	 * @format uint32
	 */
	cores_log?: number;
	/*
	 * Number of physical cores.
	 *
	 * @format uint32
	 */
	cores_pys?: number;
	/*
	 * Clock speed in MHz.
	 *
	 * @format uint32
	 */
	cpu_clock?: number;
	/*
	 * Unique identifier of the CPU, e.g. CPU serial number.
	 *
	 * @example F5KM6014F9VNF9VN
	 */
	cpu_id?: string;
	/*
	 * Name of CPU.
	 *
	 * @example Intel(R) Xeon(R) CPU E5-1650 v2 @ 3.50GHz
	 */
	cpu_name?: string;
	/*
	 * Number of processor packs
	 *
	 * @format uint32
	 */
	cpu_packs?: number;
	/*
	 * Serial number of the primary HD.
	 *
	 * @example S1FWNYADA05819
	 */
	hd_pri?: string;
	/*
	 * Memory size in bytes.
	 *
	 * @format uint64
	 */
	mem?: number;
	/*
	 * MAC address of the primary network interface.
	 *
	 * @example 70:CD:60:F4:14:61
	 */
	net_pri?: string;
	/*
	 * Operating system described by defined strings.
	 */
	os_type?:
		| "os_win_ia32"
		| "os_mac_ia32"
		| "os_linux_ia32"
		| "os_win_x64"
		| "os_mac_x64"
		| "os_linux_x64"
		| "os_linux_aarch64"
		| "os_linux_armv7"
		| "os_mac_arm64"
		| "os_unknown";
	/*
	 * Unique system id as reported by the operating system.
	 *
	 * @format uuid
	 */
	os_uuid?: string;
	/*
	 * Major version of the OS
	 *
	 * @format uint32
	 */
	os_ver_maj?: number;
	/*
	 * Minor version of the OS
	 *
	 * @format uint32
	 */
	os_ver_min?: number;
};

export type NativeIDResponse = {
	response_head: ResponseHead;
	response_body: {
		native_id: string;
	};
};

export type LicensedProductsResponse = {
	response_head: ResponseHead;
	response_body: {
		/*
		 * SDBS primary key of licensed product
		 *
		 * @example 232
		 */
		licensedproduct_id: number;
		/*
		 * @example INV221799
		 */
		order_id: string | null;
		/*
		 * @example NI-16919
		 */
		sku: string | null;
	}[];
};

export type AllLicensedProductsResponse = {
	response_head: ResponseHead;
	response_body: {
		/*
		 * SDBS primary key of licensed product
		 *
		 * @example 2888
		 */
		id: number;
		/*
		 * @example Abbey Road Modern Drummer
		 */
		title: string;
		/*
		 * @example Abbey Road Modern Drummer
		 */
		description: string;
		/*
		 * License type
		 *
		 * @example full
		 */
		license: string;
		/*
		 * Date from which licensed product is public
		 *
		 * @example "2018-10-15T10:11:11.000Z"
		 */
		public_from: string;
	}[];
};

export type RegistrationsResponse = {
	response_head: ResponseHead;
	response_body: {
		/*
		 * SDBS primary key of licensed product
		 *
		 * @example 232
		 */
		licensedproduct_id: number;
		/*
		 * @example ABSYNTH 2
		 */
		licensedproduct_title: string;
		/*
		 * @format date-time
		 */
		first_registered: string;
	}[];
};

export type Language = {
	/*
	 * @example fr
	 */
	id?: string;
	/*
	 * @example French
	 */
	title?: string;
	/*
	 * @example fr_FR
	 */
	iso_code?: string;
};

export type Country = {
	/*
	 * @example 785
	 */
	id?: number;
	/*
	 * @example Bouvet Island
	 */
	title?: string;
	/*
	 * @example BV
	 */
	iso_code?: string;
};

export type Address = {
	country?: Country;
	/*
	 * @example 491873189310
	 */
	phone?: string;
	/*
	 * @example Berlin
	 */
	city?: string;
	/*
	 * @example 11283
	 */
	zip?: string;
	/*
	 * @example Berliner Straße 42
	 */
	street?: string;
	/*
	 * @example sdbs_legacy
	 */
	type?: string;
};
